# LCR 101.分割等和子集

```java
class Solution {
    public boolean canPartition(int[] nums) {
        int sum = 0;
        for (int i = 0; i < nums.length; i++) {
            sum += nums[i];
        }
        if (sum % 2 == 1) {
            return false;
        }
        sum /= 2;
        boolean[][] dp = new boolean[nums.length][sum + 1];
        dp[0][0] = true;
        if (nums[0] > sum) {
            return false;
        }
        dp[0][nums[0]] = true;
        for (int i = 1; i < nums.length; i++) {
            for (int j = 0; j < dp[0].length; j++) {
                dp[i][j] = dp[i - 1][j];
                int index = j - nums[i];
                if (index >= 0) {
                    dp[i][j] |= dp[i - 1][index];
                }
            }
        }
        return dp[dp.length - 1][dp[0].length - 1];
    }
}
```



# LCR 110.所有可能的路径

```java
class Solution {
    List<List<Integer>> result;
    public List<List<Integer>> allPathsSourceTarget(int[][] graph) {
        result = new ArrayList<>();
        List<Integer> res = new ArrayList<>();
        res.add(0);
        findRoad(graph, res, 0);
        return result;
    }
    public void findRoad(int[][] graph, List<Integer> list, int index) {
        if (index == graph.length - 1) {
            result.add(list);
        }
        for (int i = 0; i < graph[index].length; i++) {
            List<Integer> tempList = new ArrayList<>();
            tempList.addAll(list);
            tempList.add(graph[index][i]);
            findRoad(graph, tempList, graph[index][i]);
        }
    }
}
```

# LCR 113.课程表Ⅱ

```java
class Solution {
    public int[] findOrder(int numCourses, int[][] prerequisites) {
        int len = numCourses;
        int[][] graph = new int[len][len];
        int[] in = new int[len];
        for (int[] prerequisit : prerequisites) {
            int a = prerequisit[1];
            int b = prerequisit[0];
            graph[a][b] = 1;
            in[b]++;
        }
        int[] result = new int[len];
        Arrays.fill(result, -1);
        Deque<Integer> queue = new LinkedList<>();
        for (int i = 0; i < len; i++) {
            if (in[i] == 0) {
                queue.addLast(i);
            }
        }
        int index = 0;
        while (!queue.isEmpty()) {
            int t = queue.poll();
            result[index++] = t;
            for (int u = 0; u < len; u++) {
                if (graph[t][u] == 1) {
                    in[u]--;
                    if (in[u] == 0) {
                        queue.addLast(u);
                    }
                }
            }
        }
        if (result[len - 1] == -1) {
            return new int[0];
        }
        return result;
    }
}
```

# LCR 120.寻找文件副本

```java
class Solution {
    public int findRepeatDocument(int[] documents) {
        Map<Integer, Integer> tempMap = new HashMap<>();
        for (int i = 0; i < documents.length; i++) {
            int cnt = tempMap.getOrDefault(documents[i], 0);
            if (cnt > 0) {
                return documents[i];
            }
            tempMap.put(documents[i], cnt + 1);
        }
        return -1;
    }
}
```



# LCR 122.路径加密

```java
class Solution {
    public String pathEncryption(String path) {
        return path.replace(".", " ");
    }
}
```

```java
class Solution {
    public String pathEncryption(String path) {
        char[] aa  = path.toCharArray();
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < aa.length; i++) {
            if (aa[i] == '.') {
                sb.append(" ");
            } else {
                sb.append(aa[i]);
            }
        }
        return sb.toString();
    }
}
```

# LCR 123.图书整理Ⅰ

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public int[] reverseBookList(ListNode head) {
        int size = 0;
        ListNode temp = head;
        while (head != null) {
            head = head.next;
            size++;
        }
        int index = size - 1;
        int[] result = new int[size];
        while (temp != null) {
            result[index--] = temp.val;
            temp = temp.next;
        }
        return result;
    }
}
```

# LCR 125.图书整理Ⅱ

```java
class CQueue {

    Stack<Integer> stackIn;
    Stack<Integer> stackOut;

    public CQueue() {
        stackIn = new Stack<>();
        stackOut = new Stack<>();
    }
    
    public void appendTail(int value) {
        stackIn.push(value);
    }
    
    public int deleteHead() {
        if (size() == 0) {
            return -1;
        }
        while(stackIn.size() > 0) {
            stackOut.push(stackIn.pop());
        }
        int result = stackOut.pop();
        while (stackOut.size() > 0) {
            stackIn.push(stackOut.pop());
        }
        return result;
    }

    public int size() {
        return stackIn.size();
    }
}

/**
 * Your CQueue object will be instantiated and called as such:
 * CQueue obj = new CQueue();
 * obj.appendTail(value);
 * int param_2 = obj.deleteHead();
 */
```

# LCR 126.斐波那契数列

```
class Solution {
    public int fib(int n) {
        int[] result = new int[101];
        result[0] = 0;
        result[1] = 1;
        for (int i = 2; i <= n; i++) {
            result[i] = (result[i - 1] + result[i - 2]) % 1000000007;
        }
        return result[n];
    }
}
```

# LCR 127.跳跃训练

```java
class Solution {
    public int trainWays(int num) {
        if (num < 2) {
            return 1;
        }
        int[] result = new int[num + 1];
        result[0] = 1;
        result[1] = 1;
        for (int i = 2; i <= num; i++) {
            result[i] = (result[i - 1] + result[i - 2]) % 1000000007;
        }
        return result[num];
    }
}
```

# LCR 128.库存管理Ⅰ

```java
class Solution {
    public int inventoryManagement(int[] stock) {
        int left = 0;
        int right = stock.length - 1;
        while (left < right) {
            int mid = (left + right) / 2;
            if (stock[mid] > stock[right]) {
                left = mid + 1;
            } else if (stock[mid] < stock[right]) {
                right = mid;
            } else {
                right--;
            }
        }
        return stock[right];
    }
}
```



# LCR 133.位1的个数

```java
public class Solution {
    // you need to treat n as an unsigned value
    public int hammingWeight(int n) {
        int cnt = 0;
        for (int i = 31; i >= 0; i--) {
            if (((n >> i) & 1) == 1) {
                cnt++;
            }
        }
        return cnt;
    }
}
```



# LCR 136.删除链表的节点

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode deleteNode(ListNode head, int val) {
        ListNode newHead = new ListNode(-1, head);
        ListNode node = newHead;
        while (node != null && node.next != null) {
            if (node.next.val == val) {
                node.next = node.next.next;
                break;
            }
            node = node.next;
        }
        return newHead.next;
    }
}
```



# LCR 139.训练计划Ⅰ

```java
 class Solution {
    public int[] trainingPlan(int[] actions) {
        int[] result = new int[actions.length];
        int startIndex = 0;
        int endIndex = actions.length - 1;
        for (int i = 0; i < actions.length; i++) {
            int temp = actions[i];
            if (temp % 2 == 0) {
                result[endIndex--] = temp;
            } else {
                result[startIndex++] = temp;
            }
        }
        return result;
    }
}
```

# LCR 140.训练计划Ⅱ

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode trainingPlan(ListNode head, int cnt) {
        ListNode left = head;
        ListNode right = head;
        for (int i = 0; i < cnt - 1; i++) {
            right = right.next;
        }
        while (right.next != null) {
            left = left.next;
            right = right.next;
        }
        return left;
    }
}
```

# LCR 141.训练计划Ⅲ

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode trainningPlan(ListNode head) {
        ListNode preNode = null;
        while (head != null) {
            ListNode temp = head.next;
            head.next = preNode;
            preNode = head;
            head = temp;
        }
        return preNode;
    }
}
```

# LCR 142.训练计划Ⅳ

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode trainningPlan(ListNode l1, ListNode l2) {
        ListNode newHead = new ListNode(-1);
        ListNode node = newHead;
        while (l1 != null && l2 != null) {
            if (l1.val > l2.val) {
                node.next = l2;
                l2 = l2.next;
            } else {
                node.next = l1;
                l1 = l1.next;
            }
            node = node.next;
        }
        while (l1 != null) {
            node.next = l1;
            l1 = l1.next;
            node = node.next;
        }
        while (l2 != null) {
            node.next = l2;
            l2 = l2.next;
            node = node.next;
        }
        return newHead.next;
    }
}
```

# LCR146.螺旋遍历二维数组

```java
class Solution {
    public int[] spiralArray(int[][] array) {
        if (array.length == 0) {
            return new int[]{};
        }
        if (array[0].length == 0) {
            return new int[]{};
        }
        int[][] tempArray = new int[array.length + 2][array[0].length + 2];
        for (int i = 0; i < tempArray[0].length; i++) {
            tempArray[0][i] = Integer.MIN_VALUE;
            tempArray[tempArray.length - 1][i] = Integer.MIN_VALUE;
        }
        for (int i = 0; i < tempArray.length; i++) {
            tempArray[i][0] = Integer.MIN_VALUE;
            tempArray[i][tempArray[0].length - 1] = Integer.MIN_VALUE;
        }
        for (int i = 0; i < array.length; i++) {
            for (int j = 0; j < array[0].length; j++) {
                tempArray[i + 1][j + 1] = array[i][j];
            }
        }
        int x = 1;
        int y = 1;
        int[] result = new int[array.length * array[0].length];
        int index = 0;
        while (index < result.length) {
            while (tempArray[x][y] != Integer.MIN_VALUE) {
                result[index++] = tempArray[x][y++];
                tempArray[x][y - 1] = Integer.MIN_VALUE;
            }
            y--;
            x++;
            while (tempArray[x][y] != Integer.MIN_VALUE) {
                result[index++] = tempArray[x++][y];
                tempArray[x - 1][y] = Integer.MIN_VALUE;
            }
            x--;
            y--;
            while (tempArray[x][y] != Integer.MIN_VALUE) {
                result[index++] = tempArray[x][y--];
                tempArray[x][y + 1] = Integer.MIN_VALUE;
            }
            y++;
            x--;
            while (tempArray[x][y] != Integer.MIN_VALUE) {
                result[index++] = tempArray[x--][y];
                tempArray[x + 1][y] = Integer.MIN_VALUE;
            }
            x++;
            y++;
        }
        return result;
    }
}
```



# LCR 147.最小栈

```java
class MinStack {
    
    Stack<Integer> stack;
    Stack<Integer> minStack;

    /** initialize your data structure here. */
    public MinStack() {
        stack = new Stack<>();
        minStack = new Stack<>();
        minStack.push(Integer.MAX_VALUE);
    }
    
    public void push(int x) {
        stack.push(x);
        minStack.push(Math.min(x, minStack.peek()));
    }
    
    public void pop() {
        stack.pop();
        minStack.pop();
    }
    
    public int top() {
        return stack.peek();
    }
    
    public int getMin() {
        return minStack.peek();
    }
}

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack obj = new MinStack();
 * obj.push(x);
 * obj.pop();
 * int param_3 = obj.top();
 * int param_4 = obj.getMin();
 */
```

# LCR 158.库存管理Ⅱ

```java
class Solution {
    public int inventoryManagement(int[] stock) {
        int len = stock.length;
        int size = len / 2;
        Map<Integer, Integer> tempMap = new HashMap<>();
        for (int i = 0; i < len; i++) {
            int cnt = tempMap.getOrDefault(stock[i], 0) + 1;
            if (cnt > size) {
                return stock[i];
            }
            tempMap.put(stock[i], cnt);
        }
        return -1;
    }
}
```



# LCR 159.库存管理Ⅲ

```java
class Solution {
    public int[] inventoryManagement(int[] stock, int cnt) {
        int[] result = new int[cnt];
        if (cnt == 0) {
            return result;
        }
        int len = stock.length;
        PriorityQueue<Integer> pQueue = new PriorityQueue<>(new Comparator<Integer>() {
            @Override
            public int compare(Integer n1, Integer n2) {
                return n2 - n1;
            }
        });
        for (int i = 0; i < cnt; i++) {
            pQueue.offer(stock[i]);
        }
        for (int i = cnt; i < len; i++) {
            if (pQueue.peek() > stock[i]) {
                pQueue.poll();
                pQueue.offer(stock[i]);
            }
        }
        for (int i = 0; i < cnt; i++) {
            result[i] = pQueue.poll();
        }
        return result;
    }
}
```

# LCR 161.连续天数的最高销售额

```java
class Solution {
    public int maxSales(int[] sales) {
        int len = sales.length;
        int[] result = new int[len];
        result[0] = sales[0];
        int max = sales[0];
        for (int i = 1; i < len; i++) {
            result[i] = Math.max(result[i - 1] + sales[i], sales[i]);
            max = Math.max(max, result[i]);
        }
        return max;
    }
}
```

# LCR 169.招式拆解Ⅱ

```java
class Solution {
    public char dismantlingAction(String arr) {
        int[] biubiu = new int[26];
        int[] index = new int[26];
        char[] biubiuChar = arr.toCharArray();
        for (int i = 0; i < biubiuChar.length; i++) {
            biubiu[biubiuChar[i] - 'a']++;
            index[biubiuChar[i] - 'a'] = i;
        }
        int minIndex = 99999;
        char result = ' ';
        for (int i = 0; i < biubiu.length; i++) {
            if (biubiu[i] == 1 && index[i] < minIndex) {
                minIndex = index[i];
                result = (char) (i + 'a');
            }
        }
        return result;
    }
}
```



# LCR 171.训练计划Ⅴ

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
class Solution {
    ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        Set<ListNode> tempSet = new HashSet<>();
        while (headA != null) {
            tempSet.add(headA);
            headA = headA.next;
        }
        while (headB != null) {
            if (tempSet.contains(headB)) {
                return headB;
            }
            headB = headB.next;
        }
        return null;
    }
}
```

# LCR 172.统计目标成绩的出现次数

```java
class Solution {
    public int countTarget(int[] scores, int target) {
        int left = 0;
        int right = scores.length - 1;
        int index = -1;
        while (left <= right) {
            int mid = (left + right) / 2;
            if (scores[mid] == target) {
                index = mid;
                break;
            } else if (scores[mid] > target) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        if (index == -1) {
            return 0;
        }
        int cnt = 1;
        left = index - 1;
        right = index + 1;
        while (left >= 0) {
            if (scores[left] == target) {
                cnt++;
                left--;
            } else {
                break;
            }
        }
        while (right < scores.length) {
            if (scores[right] == target) {
                cnt++;
                right++;
            } else {
                break;
            }
        }
        return cnt;
    }
}
```



# LCR 173.点名

```java
class Solution {
    public int takeAttendance(int[] records) {
        for (int i = 0; i < records.length; i++) {
            if (records[i] != i) {
                return i;
            }
        }
        return records.length;
    }
}
```

```java
class Solution {
    public int takeAttendance(int[] records) {
        int left = 0;
        int right = records.length - 1;
        while (left <= right) {
            int mid = (left + right) / 2;
            if (mid != records[mid]) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        return left;
    }
}
```



# LCR 175.计算二叉树的深度

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int calculateDepth(TreeNode root) {
        return findMaxDepth(root, 0);
    }
    public int findMaxDepth(TreeNode node, int depth) {
        if (node == null) {
            return depth;
        }
        return Math.max(findMaxDepth(node.left, depth + 1),findMaxDepth(node.right, depth + 1));
    }
}
```

# LCR 176.判断是否为平衡二叉树

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean isBalanced(TreeNode root) {
        if (root == null) {
            return true;
        }
        return Math.abs(heigth(root.left) - heigth(root.right)) <= 1 && isBalanced(root.left) && isBalanced(root.right);
    }
    public int heigth(TreeNode node) {
        if (node == null) {
            return 0;
        }
        return Math.max(heigth(node.left), heigth(node.right)) + 1;
    }
}
```

# LCR 179.查找总价格为目标值的两个商品

```java
class Solution {
    public int[] twoSum(int[] price, int target) {
        int left = 0;
        int right = price.length - 1;
        while (left < right) {
            if (price[left] + price[right] == target) {
                return new int[]{price[left], price[right]};
            } else if (price[left] + price[right] > target) {
                right--;
            } else {
                left++;
            }
        }
        return new int[]{};
    }
}
```

# LCR 181.字符串中的单词反转

```java
class Solution {
    public String reverseMessage(String message) {
        String[] words = message.trim().split("\\s+");
        StringBuilder sb = new StringBuilder();
        for (int i = words.length - 1; i >= 0; i--) {
            sb.append(words[i]);
            if (i != 0) {
                sb.append(" ");
            }
        }
        return sb.toString();
    }
}
```



# LCR 182.动态口令

```java
class Solution {
    public String dynamicPassword(String password, int target) {
        return password.substring(target) + password.substring(0, target);
    }
}
```

# LCR 183.望远镜中最高的海拔

```java
class Solution {
    public int[] maxAltitude(int[] heights, int limit) {
        int len = heights.length;
        if (len == 0) {
            return new int[0];
        }
        Deque<Integer> queue = new LinkedList<>();
        int[] result = new int[len - limit + 1];
        for (int i = 0; i < len; i++) {
            while (!queue.isEmpty() && heights[i] >= heights[queue.peekLast()]) {
                queue.pollLast();
            }
            queue.addLast(i);
            while (!queue.isEmpty() && i - limit >= queue.peekFirst()) {
                queue.pollFirst();
            }
            if (i - limit >= -1) {
                result[i - limit + 1] = heights[queue.peekFirst()];
            }
        }
        return result;
    }
}
```

# LCR 186.文物朝代判断

```java
class Solution {
    public boolean checkDynasty(int[] places) {
        Arrays.sort(places);
        int min = -1;
        int max = places[places.length - 1];
        int minIndex = -1;
        for (int i = 0; i < places.length; i++) {
            if (places[i] != 0) {
                min = places[i];
                minIndex = i;
                break;
            }
        }
        for (int i = minIndex; i < places.length - 1; i++) {
            if (places[i] == places[i + 1]) {
                return false;
            }
        }
        if (min == 0 || max == 0 || min == max) {
            return true;
        }
        return places[places.length - 1] - places[minIndex] <= 4;
    }
}
```



# LCR 189.设计机械累加器

```java
class Solution {
    public int mechanicalAccumulator(int target) {
        int sum = 0;
        for (int i = 1; i <= target; i++) {
            sum += i;
        }
        return sum;
    }
}
```

```java
class Solution {
    public int mechanicalAccumulator(int target) {
        return (1+target)*target / 2;
    }
}
```

# LCR 190.加密运算

```java
class Solution {
    public int encryptionCalculate(int dataA, int dataB) {
        return dataA+dataB;
    }
}
```

