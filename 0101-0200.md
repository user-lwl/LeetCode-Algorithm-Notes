# 101.对称二叉树

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean isSymmetric(TreeNode root) {
        return getResult(root.left, root.right);
    }

    public boolean getResult(TreeNode pNode, TreeNode qNode) {
        if (pNode != null && qNode != null && pNode.val == qNode.val) {
            return getResult(pNode.left, qNode.right) && getResult(pNode.right, qNode.left);
        }
        return pNode == qNode;
    }
}
```



# 104.二叉树的最大深度

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int maxDepth(TreeNode root) {
        return selectMaxDepth(root, 0);
    }
    public int selectMaxDepth(TreeNode node, int depth) {
        if (node == null) {
            return depth;
        }
        return Math.max(selectMaxDepth(node.left, depth+1), selectMaxDepth(node.right, depth+1));
    }
}
```

# 108.将有序数组转换为二叉搜索树

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        int len = nums.length;
        return createTree(nums, 0, len - 1);
    }
    public TreeNode createTree(int[] nums, int left, int right) {
        if (left > right) {
            return null;
        }
        int mid = (left + right) / 2;
        TreeNode root = new TreeNode(nums[mid], createTree(nums, left, mid - 1), createTree(nums, mid + 1, right));
        return root;
    }
}
```

# 110.平衡二叉树

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean isBalanced(TreeNode root) {
        if (root == null) {
            return true;
        }
        return Math.abs(height(root.left) - height(root.right)) <= 1 && isBalanced(root.left) && isBalanced(root.right);
    }
    public int height(TreeNode node) {
        if (node == null) {
            return 0;
        }
        return Math.max(height(node.left), height(node.right)) + 1;
    }
}
```

# 111.二叉树的最小深度

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int minDepth(TreeNode root) {
        if (root == null) {
            return 0;
        }
        return getMinDepth(root, 1);
    }

    public int getMinDepth(TreeNode node, int depth) {
        if (node != null && node.left == null && node.right == null) {
            return depth;
        }
        int left = Integer.MAX_VALUE;
        int right = Integer.MAX_VALUE;
        if (node.left != null) {
            left = getMinDepth(node.left, depth + 1);
        }
        if (node.right != null) {
            right = getMinDepth(node.right, depth + 1);
        }
        return Math.min(left, right);
    }
}
```

# 112.路径总和

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {

    int target;

    public boolean hasPathSum(TreeNode root, int targetSum) {
        target = targetSum;
        if (root == null) {
            return false;
        }
        return isequal(root, 0);
    }

    public boolean isequal(TreeNode node, int nowSum) {
        int value = node.val;
        if (node.left == null && node.right == null) {
            return nowSum + value == target;
        }
        boolean leftValue = false;
        boolean rightValue = false;
        if (node.left != null) {
            leftValue = isequal(node.left, nowSum + value);
        }
        if (node.right != null) {
            rightValue = isequal(node.right, nowSum + value);
        }
        return leftValue || rightValue;
    }
}
```

# 118.杨辉三角

```java
class Solution {
    public List<List<Integer>> generate(int numRows) {
        List<List<Integer>> resultList = new ArrayList<>();
        for (int i = 0; i < numRows; i++) {
            List<Integer> tempList = new ArrayList<>();
            resultList.add(tempList);
        }
        resultList.get(0).add(1);
        for (int i = 1; i < numRows; i++) {
            List<Integer> tempList = resultList.get(i);
            List<Integer> tempTopList = resultList.get(i - 1);
            tempList.add(1);
            for (int j = 1; j < i; j++) {
                tempList.add(tempTopList.get(j - 1) + tempTopList.get(j));
            }
            tempList.add(1);
        }
        return resultList;
    }
}
```

# 119.杨辉三角Ⅱ

```java
class Solution {
    public List<Integer> getRow(int rowIndex) {
        List<List<Integer>> resultList = new ArrayList<>();
        for (int i = 0; i < rowIndex + 1; i++) {
            List<Integer> tempList = new ArrayList<>();
            resultList.add(tempList);
        }
        resultList.get(0).add(1);
        for (int i = 1; i < rowIndex + 1; i++) {
            List<Integer> tempList = resultList.get(i);
            List<Integer> tempTopList = resultList.get(i - 1);
            tempList.add(1);
            for (int j = 1; j < i; j++) {
                tempList.add(tempTopList.get(j - 1) + tempTopList.get(j));
            }
            tempList.add(1);
        }
        return resultList.get(rowIndex);
    }
}
```

# 120.三角形最小路径和

```java
class Solution {
    public int minimumTotal(List<List<Integer>> triangle) {
        int[][] dp = new int[triangle.size()][triangle.size()];
        dp[0][0] = triangle.get(0).get(0);
        for (int i = 1; i < dp.length; i++) {
            dp[i][0] = dp[i -1][0] + triangle.get(i).get(0);
            for (int j = 1; j < i; j++) {
                dp[i][j] = Math.min(dp[i - 1][j - 1], dp[i - 1][j]) + triangle.get(i).get(j);
            }
            dp[i][i] = dp[i - 1][i - 1] + triangle.get(i).get(i);
        }
        int min = dp[dp.length - 1][0];
        for (int i = 1; i < dp.length; i++) {
            min = Math.min(min, dp[dp.length - 1][i]);
        }
        return min;
    }
}
```

# 121.买卖股票的最佳时机

```java
class Solution {
    public int maxProfit(int[] prices) {
        int max = 0;
        int min = 9999;
        int len = prices.length;
        for (int i = 0; i < len; i++) {
            min = Math.min(min, prices[i]);
            max = Math.max(max, prices[i] - min);
        }
        return max;
    }
}
```

# 125.验证回文串

```java
class Solution {
    public boolean isPalindrome(String s) {
        char[] sChar = s.toCharArray();
        int tempInt = 'A' - 'a';
        Deque<Character> queue = new LinkedList<>();
        for (int i = 0; i < sChar.length; i++) {
            char tempChar = sChar[i];
            if (tempChar >= 'A' && tempChar <= 'Z') {
                tempChar -= tempInt;
                queue.addLast(tempChar);
            } else if (tempChar >= 'a' && tempChar <= 'z') {
                queue.addLast(tempChar);
            } else if (tempChar >= '0' && tempChar <= '9') {
                queue.addLast(tempChar);
            }
        }
        while (queue.size() > 1) {
            char char1 = queue.removeFirst();
            char char2 = queue.removeLast();
            if (char1 != char2) {
                return false;
            }
        }
        return true;
    }
}
```



# 136.只出现一次的数字

```java
class Solution {
    public int singleNumber(int[] nums) {
        int count = 0;
        int n = nums.length;
        for (int i = 0; i < n; i++) {
            count ^= nums[i];
        }
        return count;
    }
}
```

# 141.环形链表

```java
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public boolean hasCycle(ListNode head) {
        Set<ListNode> hashSet = new HashSet<>();
        while (head != null) {
            if (!hashSet.add(head)) {
                return true;
            }
            head = head.next;
        }
        return false;
    }
}
```



# 143.重排链表

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public void reorderList(ListNode head) {
        Deque<ListNode> queue = new LinkedList<>();
        int index = 0;
        while (head != null) {
            queue.add(head);
            head = head.next;
        }
        ListNode newHead = new ListNode(-1);
        ListNode node = newHead;
        while (queue.size() > 0) {
            ListNode temp1 = queue.pollFirst();
            node.next = temp1;
            node = node.next;
            if (queue.size() > 0) {
                ListNode temp2 = queue.pollLast();
                node.next = temp2;
                node = node.next;
            }
        }
        node.next = null;
        head = newHead.next;
    }
}
```

# 144.二叉树的前序遍历

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        before(root, result);
        return result;
    }
    public void before (TreeNode node, List<Integer> list) {
        if (node == null) {
            return;
        }
        list.add(node.val);
        before(node.left, list);
        before(node.right, list);
    }
}
```

# 145.二叉树的后序遍历

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        postorder(root, result);
        return result;
    }
    public void postorder(TreeNode node, List<Integer> list) {
        if (node == null) {
            return;
        }
        postorder(node.left, list);
        postorder(node.right, list);
        list.add(node.val);
    }
}
```

# 146. LRU缓存

```java
class LRUCache {

    class Node {
        public int key;
        public int value;
        public Node prev;
        public Node next;
        public Node child;
        Node() {  }
        Node(int k, int v) { value = v; key = k; }
        Node(int k, int v, Node n) { value = v; key = k; next = n; }
    };

    int size;
    int capacity;
    Node head;
    Node tail;
    Map<Integer, Node> map = new HashMap<>();

    public LRUCache(int capacity) {
        size = 0;
        this.capacity = capacity;
        head = new Node();
        tail = new Node();
        head.next = tail;
        tail.prev = head;
    }
    
    public int get(int key) {
        Node result = map.get(key);
        if (result == null) {
            return -1;
        }
        moveToHead(result);
        return result.value;
    }
    
    public void put(int key, int value) {
        Node node = map.get(key);
        if(node == null) {
            node = new Node(key, value);
            map.put(key, node);
            addToHead(node);
            size++;
            if (size > capacity) {
                Node remove = removeTail();
                map.remove(remove.key);
                size--;
            }
        } else {
            node.value = value;
            moveToHead(node);
        }
    }

    public void addToHead(Node node) {
        node.prev = head;
        node.next = head.next;
        head.next.prev = node;
        head.next = node;
    }

    public void removeNode(Node node) {
        node.prev.next = node.next;
        node.next.prev = node.prev;
    }

    public void moveToHead(Node node) {
        removeNode(node);
        addToHead(node);
    }

    public Node removeTail() {
        Node node = tail.prev;
        removeNode(node);
        return node;
    }

}

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache obj = new LRUCache(capacity);
 * int param_1 = obj.get(key);
 * obj.put(key,value);
 */
```

# 147.对链表进行插入排序

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode insertionSortList(ListNode head) {
        ListNode newHead = new ListNode(-5001, head);
        ListNode node = head.next;
        head.next = null;
        while (node != null) {
            ListNode tempNode = node;
            node = node.next;
            int val = tempNode.val;
            ListNode nodeT = newHead;
            while (nodeT != null) {
                if (nodeT.val < val) {
                    if (nodeT.next == null || nodeT.next.val >= val) {
                        ListNode nextNode = nodeT.next;
                        nodeT.next = tempNode;
                        tempNode.next = nextNode;
                        break;
                    }
                }
                nodeT = nodeT.next;
            }
        }
        return newHead.next;
    }
}
```

# 148.排序链表

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode sortList(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }
        ListNode slow = head;
        ListNode fast = head;
        ListNode pre = head;
        while (fast != null) {
            pre = slow;
            slow = slow.next;
            fast = fast.next;
            if (fast != null) {
                fast = fast.next;
            }
        }
        ListNode mid = pre.next;
        pre.next = null;
        return mergeSrot(sortList(head), sortList(mid));
    }
    public ListNode mergeSrot(ListNode node1, ListNode node2) {
        ListNode result = new ListNode();
        ListNode temp = result;
        // 归并
        while (node1 != null && node2 != null) {
            if (node1.val > node2.val) {
                temp.next = node2;
                node2 = node2.next;
            } else {
                temp.next = node1;
                node1 = node1.next;
            }
            temp = temp.next;
        }
        if (node1 != null) {
            temp.next = node1;
        }
        if (node2 != null) {
            temp.next = node2;
        }
        return result.next;
    }
}
```

# 153.寻找旋转排序数组中的最小值

```java
class Solution {
    public int findMin(int[] nums) {
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] < nums[0]) {
                return nums[i];
            }
        }
        return nums[0];
    }
}
```

# 154.寻找旋转排序数组中的最小值Ⅱ

```java
class Solution {
    public int findMin(int[] nums) {
        int left = 0;
        int right = nums.length - 1;
        while (left < right) {
            int mid = (left + right) / 2;
            if (nums[mid] > nums[right]) {
                left = mid + 1;
            } else if (nums[mid] < nums[right]) {
                right = mid;
            } else {
                right--;
            }
        }
        return nums[right];
    }
}
```



# 155.最小栈

```java
class MinStack {

    Stack<Integer> stack;
    Stack<Integer> minStack;

    public MinStack() {
        stack = new Stack<>();
        minStack = new Stack<>();
        minStack.push(Integer.MAX_VALUE);
    }
    
    public void push(int val) {
        stack.push(val);
        minStack.push(Math.min(minStack.peek(), val));
    }
    
    public void pop() {
        stack.pop();
        minStack.pop();
    }
    
    public int top() {
        return stack.peek();
    }
    
    public int getMin() {
        return minStack.peek();
    }
}

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack obj = new MinStack();
 * obj.push(val);
 * obj.pop();
 * int param_3 = obj.top();
 * int param_4 = obj.getMin();
 */
```

# 160.相交链表

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        Set<ListNode> set = new HashSet<>();
        ListNode nodeA = headA;
        while (nodeA != null) {
            set.add(nodeA);
            nodeA = nodeA.next;
        }
        ListNode nodeB = headB;
        while (nodeB != null) {
            if (set.contains(nodeB)) {
                return nodeB;
            }
            nodeB = nodeB.next;
        }
        return null;
    }
}
```

# 163.岛屿的周长

```java
class Solution {
    int[] dx = {0, 1, 0, -1};
    int[] dy = {1, 0, -1, 0};
    public int islandPerimeter(int[][] grid) {
        int sum = 0;
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[0].length; j++){
                if (grid[i][j] == 1) {
                    sum += check(grid, i, j);
                }
            }
        }
        return sum;
    }
    public int check(int[][] grid, int i, int j) {
        int sum = 0;
        for (int k = 0; k < 4; k++) {
            int x = i + dx[k];
            int y = j + dy[k];
            if (x < 0 || x >= grid.length || y < 0 || y >= grid[0].length || grid[x][y] == 0) {
                sum++;
            }
        }
        return sum;
    }
}
```

# 164.最大间距

```java
class Solution {
    public int maximumGap(int[] nums) {
        if (nums.length < 2) {
            return 0;
        }
        Arrays.sort(nums);
        int result = 0;
        for (int i = 0; i < nums.length - 1; i++) {
            result = result < (nums[i + 1] - nums[i]) ? (nums[i + 1] - nums[i]) : result;
        }
        return result;
    }
}
```

# 165.比较版本号

```java
class Solution {
    public int compareVersion(String version1, String version2) {
        String[] version1List = version1.split("\\.");
        String[] version2List = version2.split("\\.");
        int[] version1IntList = new int[Math.max(version1List.length, version2List.length)];
        int[] version2IntList = new int[Math.max(version1List.length, version2List.length)];
        for (int i = 0; i < version1List.length; i++) {
            int temp = Integer.parseInt(version1List[i]);
            version1IntList[i] = temp;
        }
        for (int i = 0; i < version2List.length; i++) {
            int temp = Integer.parseInt(version2List[i]);
            version2IntList[i] = temp;
        }
        for (int i = 0; i < version1IntList.length; i++) {
            if (version1IntList[i] > version2IntList[i]) {
                return 1;
            } else if (version1IntList[i] < version2IntList[i]) {
                return -1;
            }
        }
        return 0;
    }
}
```

# 167.两数之和Ⅱ - 输入有序数组

```java
class Solution {
    public int[] twoSum(int[] numbers, int target) {
        int left = 0;
        int right = numbers.length - 1;
        while (left < right) {
            if (numbers[left] + numbers[right] > target) {
                right--;
            } else if (numbers[left] + numbers[right] < target) {
                left++;
            } else {
                return new int[]{left + 1, right + 1};
            }
        }
        return new int[]{-1, -1};
    }
}
```



# 168.Excel表列名称

```java
class Solution {
    public String convertToTitle(int columnNumber) {
        Map<Integer, String> resultMap = new HashMap<>();
        resultMap.put(1, "A");
        resultMap.put(2, "B");
        resultMap.put(3, "C");
        resultMap.put(4, "D");
        resultMap.put(5, "E");
        resultMap.put(6, "F");
        resultMap.put(7, "G");
        resultMap.put(8, "H");
        resultMap.put(9, "I");
        resultMap.put(10, "J");
        resultMap.put(11, "K");
        resultMap.put(12, "L");
        resultMap.put(13, "M");
        resultMap.put(14, "N");
        resultMap.put(15, "O");
        resultMap.put(16, "P");
        resultMap.put(17, "Q");
        resultMap.put(18, "R");
        resultMap.put(19, "S");
        resultMap.put(20, "T");
        resultMap.put(21, "U");
        resultMap.put(22, "V");
        resultMap.put(23, "W");
        resultMap.put(24, "X");
        resultMap.put(25, "Y");
        resultMap.put(0, "Z");
        Stack<String> resultStack = new Stack<>();
        while (columnNumber > 0) {
            int number = columnNumber % 26;
            columnNumber = (columnNumber - 1) / 26;
            resultStack.push(resultMap.get(number));
        }
        StringBuilder sb = new StringBuilder();
        while (!resultStack.isEmpty()) {
            sb.append(resultStack.pop());
        }
        return sb.toString();
    }
}
```

# 169.多数元素

```java
class Solution {
    public int majorityElement(int[] nums) {
        Arrays.sort(nums);
        return nums[nums.length / 2];
    }
}
```

```java
class Solution {
    public int majorityElement(int[] nums) {
        int len = nums.length;
        quickSort(nums, 0, len - 1);
        return nums[len / 2];
    }
    public void swap(int[] nums, int left, int right) {
        int temp = nums[left];
        nums[left] = nums[right];
        nums[right] = temp;
    }
    public int partition(int[] nums, int left, int right) {
        int mid = new Random().nextInt(right - left + 1) + left;
        swap(nums, left, mid);
        int j = left + 1;
        for (int i = left + 1; i <= right; i++) {
            if (nums[i] < nums[left]) {
                swap(nums, i, j++);
            }
        }
        swap(nums, j - 1, left);
        return j - 1;
    }
    public void quickSort(int[] nums, int left, int right) {
        if (left < right) {
            int mid = partition(nums, left, right);
            quickSort(nums, left, mid - 1);
            quickSort(nums, mid + 1, right);
        }
    }
}
```

# 171.Excel表列序号

```java
class Solution {
    public int titleToNumber(String columnTitle) {
        Map<Character, Integer> resultMap = new HashMap<>();
        resultMap.put('A', 1);
        resultMap.put('B', 2);
        resultMap.put('C', 3);
        resultMap.put('D', 4);
        resultMap.put('E', 5);
        resultMap.put('F', 6);
        resultMap.put('G', 7);
        resultMap.put('H', 8);
        resultMap.put('I', 9);
        resultMap.put('J', 10);
        resultMap.put('K', 11);
        resultMap.put('L', 12);
        resultMap.put('M', 13);
        resultMap.put('N', 14);
        resultMap.put('O', 15);
        resultMap.put('P', 16);
        resultMap.put('Q', 17);
        resultMap.put('R', 18);
        resultMap.put('S', 19);
        resultMap.put('T', 20);
        resultMap.put('U', 21);
        resultMap.put('V', 22);
        resultMap.put('W', 23);
        resultMap.put('X', 24);
        resultMap.put('Y', 25);
        resultMap.put('Z', 26);
        char[] excelChar = columnTitle.toCharArray();
        int result = 0;
        for (int i = 0; i < excelChar.length; i++) {
            char tempChar = excelChar[i];
            int number = resultMap.get(tempChar);
            result = result * 26 + number;
        }
        return result;
    }
}
```

# 172.阶乘后的零

```java
class Solution {
    public int trailingZeroes(int n) {
        if (n <5) {
            return 0;
        }
        return n / 5 + trailingZeroes(n / 5);
    }
}
```

# 175.组合两个表

```sql
# Write your MySQL query statement below
select a.FirstName, a.LastName, b.City, b.State from Person a left join Address b on a.PersonId = b.PersonId;
```

# 181.超过经理收入的员工

```sql
# Write your MySQL query statement below
select b.name Employee from 
Employee a,
Employee b
where b.managerId = a.id and b.salary > a.salary
```

# 182.查找重复的电子邮箱

```sql
# Write your MySQL query statement below
select a.email from (
select email, count(*) cnt from Person group by email
) a where a.cnt > 1;
```

# 183.从不订购的客户

```sql
# Write your MySQL query statement below
select name Customers from Customers where id not in 
(select customerId from Orders)
```

# 190.颠倒二进制位

```java
class Solution {
    public int reverseBits(int n) {
        int[] number = new int[32];
        int index = 0;
        while (n > 0) {
            int temp = n % 2;
            n = n / 2;
            number[index++] = temp;
        }
        int result = 0;
        for (int i = 0; i < number.length; i++) {
            result = result * 2 + number[i];
        }
        return result;
    }
}
```

# 191.位1的个数

```java
class Solution {
    public int hammingWeight(int n) {
        int count = 0;
        while (n != 0) {
            n &= n - 1;
            count++;
        }
        return count;
    }
}
```

# 196.删除重复的电子邮箱

```sql
# Write your MySQL query statement below
delete from Person where id not in 
(select a.id from (select email, min(id) id from Person group by email) a)
```

# 197.上升的温度

```sql
# Write your MySQL query statement below
select b.id from Weather a, Weather b where a.recordDate = DATE_SUB(b.recordDate, INTERVAL 1 DAY) and a.temperature < b.temperature;
```

# 198.打家劫舍

```java
class Solution {
    public int rob(int[] nums) {
        int len = nums.length;
        if (len == 1) {
            return nums[0];
        }
        int[] dp = new int[len];
        dp[0] = nums[0];
        dp[1] = Math.max(dp[0], nums[1]);
        for (int i = 2; i < len; i++) {
            dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);
        }
        return dp[len - 1];
    }
}
```

### 