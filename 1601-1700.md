# 1603.设计停车系统

```java
class ParkingSystem {

    int[] carPark = new int[3];

    public ParkingSystem(int big, int medium, int small) {
        carPark[0] = big;
        carPark[1] = medium;
        carPark[2] = small;
    }
    
    public boolean addCar(int carType) {
        carPark[carType - 1]--;
        if (carPark[carType - 1] < 0) {
            return false;
        }
        return true;
    }
}

/**
 * Your ParkingSystem object will be instantiated and called as such:
 * ParkingSystem obj = new ParkingSystem(big, medium, small);
 * boolean param_1 = obj.addCar(carType);
 */
```



# 1608.特殊数组的特征值

```java
class Solution {
    public int specialArray(int[] nums) {
        Arrays.sort(nums);
        int len = nums.length;
        if (nums[0] >= len) {
            return len;
        }
        for (int i = 1; i < len; i++) {
            if (nums[len - i] >= i && nums[len - i - 1] < i) {
                return i;
            }
        }
        return -1;
    }
}
```



# 1614.括号的最大嵌套深度

```java
class Solution {
    public int maxDepth(String s) {
        char[] c = s.toCharArray();
        int max = 0;
        Stack<Character> stack = new Stack<>();
        for (int i = 0; i < c.length; i++) {
            if (c[i] == '(') {
                stack.push(c[i]);
                max = Math.max(stack.size(), max);
            } 
            if (c[i] == ')') {
                stack.pop();
            }
        }
        return max;
    }
}
```



# 1619.删除某些元素的数组均值

```java
class Solution {
    public double trimMean(int[] arr) {
        insertSort(arr);
        int len = arr.length; 
        int per = (int) (len * 0.05);
        int sum = 0;
        for (int i = per; i < len - per; i++) {
            sum += arr[i];
            System.out.println(arr[i]);
        }
        return (double)sum / (len - 2 * per);
    }
    public void insertSort(int[] a) {
        int len = a.length;
        for (int i = 1; i < len; i++) {
            int temp = a[i];
            int j = i - 1;
            while (j >= 0) {
                if (a[j] > temp) {
                    a[j + 1] = a[j];
                    j--;
                } else {
                    break;
                }
            }
            a[j + 1] = temp;
        }
    }
}
```

# 1624.两个相同字符之间的最长子字符串

```java
class Solution {
    public int maxLengthBetweenEqualCharacters(String s) {
        Map<Character, List<Integer>> resultMap = new HashMap<>();
        char[] sChar = s.toCharArray();
        for (int i = 0; i < sChar.length; i++) {
            List<Integer> tempList = resultMap.getOrDefault(sChar[i], new ArrayList<>());
            tempList.add(i);
            resultMap.put(sChar[i], tempList);
        }
        int result = -1;
        for (Character key : resultMap.keySet()) {
            List<Integer> tempList = resultMap.get(key);
            if (tempList.size() > 1) {
                result = Math.max(result, tempList.get(tempList.size() - 1) - tempList.get(0) - 1);
            }
        }
        return result;
    }
}
```

# 1629.按键持续时间最长的键

```java
class Solution {
    public char slowestKey(int[] releaseTimes, String keysPressed) {
        int[] time = new int[26];
        for (int i = 0; i < releaseTimes.length; i++) {
            int index = keysPressed.charAt(i) - 'a';
            time[index] = Math.max(releaseTimes[i] - (i > 0 ? releaseTimes[i - 1] : 0), time[index]);
        }
        int maxTime = 0;
        char result = ' ';
        for (int i = 0; i < time.length; i++) {
            if (maxTime <= time[i]) {
                maxTime = time[i];
                result = (char) ('a' + i);
            }
        }
        return result;
    }
}
```



# 1636.按照频率将数组升序排序

```java
class Solution {
    public int[] frequencySort(int[] nums) {
        Map<Integer, Integer> cntMap = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            cntMap.put(nums[i], cntMap.getOrDefault(nums[i], 0) + 1);
        }
        int[][] tempList = new int[cntMap.size()][2];
        int index = 0;
        for (Integer tempInt : cntMap.keySet()) {
            tempList[index][0] = tempInt;
            tempList[index][1] = cntMap.get(tempInt);
            index++;
        }
        Arrays.sort(tempList, new Comparator<int[]>() {
            public int compare(int[] o1, int[] o2) {
                if (o1[1] != o2[1]) {
                    return o1[1] - o2[1];
                } else {
                    return o2[0] - o1[0];
                }
            }
        });
        int[] reuslt = new int[nums.length];
        int tempIndex = 0;
        for (int i = 0; i < tempList.length; i++) {
            int number = tempList[i][0];
            int count = tempList[i][1];
            while (count > 0) {
                reuslt[tempIndex++] = number;
                count--;
            }
        }
        return reuslt;
    }
}
```

# 1637.两点之间不包含任何点的最宽垂直区域

```java
class Solution {
    public int maxWidthOfVerticalArea(int[][] points) {
        Set<Integer> tempSet = new HashSet<>();
        for (int i = 0; i < points.length; i++) {
            tempSet.add(points[i][0]);
        }
        int[] tempList = new int[tempSet.size()];
        int index = 0;
        for (Integer tempInt : tempSet) {
            tempList[index++] = tempInt;
        }
        Arrays.sort(tempList);
        int result = 0;
        for (int i = 1; i < tempList.length; i++) {
            result = Math.max(result, tempList[i] - tempList[i - 1]);
        }
        return result;
    }
}
```

# 1640.能否连接形成数组

```java
class Solution {
    public boolean canFormArray(int[] arr, int[][] pieces) {
        Map<Integer, Integer> arrMap = new HashMap<>();
        for (int i = 0; i < arr.length; i++) {
            arrMap.put(arr[i], i);
        }
        for (int i = 0; i < pieces.length; i++) {
            for (int j = 0; j < pieces[i].length; j++) {
                int thisIndex = arrMap.getOrDefault(pieces[i][j], -1);
                if (j == 0) {
                    if (thisIndex == -1) {
                        return false;
                    }
                    continue;
                }
                int preIndex = arrMap.getOrDefault(pieces[i][j - 1], -1);
                if (thisIndex - preIndex != 1 || thisIndex == -1 || preIndex == -1) {
                    return false;
                }
            }
        }
        return true;
    }
}
```

# 1646.获取生成数组中的最大值

```java
class Solution {
    public int getMaximumGenerated(int n) {
        int[] result = new int[n + 1];
        result[0] = 0;
        if (result.length == 1) {
            return result[0];
        }
        result[1] = 1;
        int max = 1;
        for (int i = 2; i < result.length; i++) {
            int temp = i / 2;
            if (i % 2 == 0) {
                result[i] = result[temp];
            } else {
                result[i] = result[temp] + result[temp + 1];
            }
            max = Math.max(max, result[i]);
        }
        return max;
    }
}
```



# 1652.拆炸弹

```java
class Solution {
    public int[] decrypt(int[] code, int k) {
        int[] tempCode = new int[code.length * 2];
        System.arraycopy(code, 0, tempCode, 0, code.length);
        System.arraycopy(code, 0, tempCode, code.length, code.length);
        int[] result = new int[code.length];
        if (k == 0) {
            return result;
        }
        int left = k > 0 ? 1 : code.length + k;
        int right = k > 0 ? k : code.length - 1;
        int sum = 0;
        for (int i = left; i <= right; i++) {
            sum += tempCode[i];
        }
        for (int i = 0; i < result.length; i++) {
            result[i] = sum;
            sum -= tempCode[left++];
            right++;
            sum += tempCode[right];
        }
        return result;
    }
}
```



# 1656.设计有序流

```java
class OrderedStream {

    String[] result;

    int index = 1;

    public OrderedStream(int n) {
        result = new String[n + 1];
    }
    
    public List<String> insert(int idKey, String value) {
        result[idKey] = value;
        List<String> returnList = new ArrayList<>();
        while (index < result.length && result[index] != null) {
            returnList.add(result[index++]);
        }
        return returnList;
    }
}

/**
 * Your OrderedStream object will be instantiated and called as such:
 * OrderedStream obj = new OrderedStream(n);
 * List<String> param_1 = obj.insert(idKey,value);
 */
```

# 1662.检查两个字符串数组是否相等

```java
class Solution {
    public boolean arrayStringsAreEqual(String[] word1, String[] word2) {
        StringBuilder word1Sb = new StringBuilder();
        StringBuilder word2Sb = new StringBuilder();
        for (int i = 0; i < word1.length; i++) {
            word1Sb.append(word1[i]);
        }
        for (int i = 0; i < word2.length; i++) {
            word2Sb.append(word2[i]);
        }
        return word1Sb.toString().equals(word2Sb.toString());
    }
}
```



# 1664.数组中两元素的最大乘积

```java
class Solution {
    public int maxProduct(int[] nums) {
        bubblSort(nums);
        int len = nums.length;
        return (nums[len - 1] - 1) * (nums[len - 2] - 1);
    }
    public void bubblSort(int[] num) {
        int len = num.length;
        for (int i = len - 1; i > 0; i--) {
            for (int j = 0; j < i; j++) {
                if (num[j] > num[i]) {
                    int temp = num[j];
                    num[j] = num[i];
                    num[i] = temp;
                }
            }
        }
    }
}
```

# 1668.最大重复子字符串

```java
class Solution {
    public int maxRepeating(String sequence, String word) {
        StringBuilder sb = new StringBuilder();
        int cnt = 0;
        sb.append(word);
        while (sequence.indexOf(sb.toString()) != -1) {
            cnt++;
            sb.append(word);
        }
        return cnt;
    }
}
```



# 1669.合并两个链表

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {
        ListNode newHead = new ListNode(-1, list1);
        ListNode node = newHead;
        int len = b - a + 1;
        while (a > 0) {
            node = node.next;
            a--;
        }
        ListNode firstTail = node;
        while (len > 0) {
            node = node.next;
            len--;
        }
        ListNode lastHead = node.next;
        ListNode l2Head = list2;
        while (list2.next != null) {
            list2 = list2.next;
        }
        ListNode l2Tail = list2;
        firstTail.next = l2Head;
        l2Tail.next = lastHead;
        return newHead.next;
    }
}
```



# 1672.最富有客户的资产总量

```java
class Solution {
    public int maximumWealth(int[][] accounts) {
        int sum = 0;
        for (int i = 0; i < accounts.length; i++) {
            int temp = 0;
            for (int j = 0; j < accounts[0].length; j++) {
                temp += accounts[i][j];
            }
            if (sum < temp) {
                sum = temp;
            }
        }
        return sum;
    }
}
```



# 1678.设计Goal解析器

```java
class Solution {
    public String interpret(String command) {
        char[] c = command.toCharArray();
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < c.length; i++) {
            if (c[i] == 'G') {
                sb.append('G');
            } else if (c[i] == '(' && c[i + 1] == ')') {
                sb.append('o');
                i++;
            } else {
                sb.append("al");
                i += 3;
            }
        }
        return sb.toString();
    }
}
```



# 1684.统计一致字符串的数目

```java
class Solution {
    public int countConsistentStrings(String allowed, String[] words) {
        int result = 0;
        for (int i = 0; i < words.length; i++) {
            boolean isTrue = true;
            for (int j = 0; j < words[i].length(); j++) {
                if (allowed.indexOf(words[i].charAt(j)) < 0) {
                    isTrue = false;
                    break;
                }
            }
            if (isTrue) {
                result++;
            }
        }
        return result;
    }
}
```

# 1688.比赛中的配对次数

```java
class Solution {
    public int numberOfMatches(int n) {
        int result = 0;
        while (n > 1) {
            if (n % 2 == 0) {
                result += n / 2;
                n /= 2;
            } else {
                result += (n - 1) / 2;
                n = (n - 1) / 2 + 1;
            }
        }
        return result;
    }
}
```



# 1694.重新格式化电话号码

```java
class Solution {
    public String reformatNumber(String number) {
        List<Integer> numberList = new ArrayList<>();
        for (int i = 0; i < number.length(); i++) {
            char temp = number.charAt(i);
            if (Character.isDigit(temp)) {
                numberList.add(temp - '0');
            }
        }
        StringBuilder sb = new StringBuilder();
        int i = 0;
        for (; i < numberList.size() - 4; i+=3) {
            sb.append(numberList.get(i)).append(numberList.get(i + 1)).append(numberList.get(i + 2)).append('-');
        }
        if (numberList.size() - i == 4) {
            sb.append(numberList.get(i)).append(numberList.get(i + 1)).append('-').append(numberList.get(i + 2)).append(numberList.get(i + 3));
        } else if (numberList.size() - i == 3) {
            sb.append(numberList.get(i)).append(numberList.get(i + 1)).append(numberList.get(i + 2));
        } else {
            sb.append(numberList.get(i)).append(numberList.get(i + 1));
        }
        return sb.toString();
    }
}
```



# 1696.跳跃游戏Ⅵ

```java
class Solution {
    public int maxResult(int[] nums, int k) {
        int len = nums.length;
        Deque<Integer> queue = new LinkedList<>();
        int[] result = new int[len];
        result[0] = nums[0];
        queue.addLast(0);
        for (int i = 1; i < len; i++) {
            while (!queue.isEmpty() && i - queue.peekFirst() > k) {
                queue.pollFirst();
            }
            result[i] = nums[i] + result[queue.peekFirst()];
            while (!queue.isEmpty() && result[i] >= result[queue.peekLast()]) {
                queue.pollLast();
            }
            queue.addLast(i);
        }
        return result[len - 1];
    }
}
```

# 1700.无法吃午餐的学生数量

```java
class Solution {
    public int countStudents(int[] students, int[] sandwiches) {
        int zeroCnt = 0;
        int oneCnt = 0;
        for (int i = 0; i < students.length; i++) {
            if (students[i] == 0) {
                zeroCnt++;
            } else {
                oneCnt++;
            }
        }
        int index = 0;
        for (; index < sandwiches.length; index++) {
            if (sandwiches[index] == 0) {
                if (zeroCnt == 0) {
                    break;
                }
                zeroCnt--;
            } else {
                if (oneCnt == 0) {
                    break;
                }
                oneCnt--;
            }
        }
        return zeroCnt + oneCnt;
    }
}
```

