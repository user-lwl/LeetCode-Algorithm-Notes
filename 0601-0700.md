# 605.种花问题

```java
class Solution {
    public boolean canPlaceFlowers(int[] flowerbed, int n) {
        if (flowerbed[0] == 0 && (flowerbed.length == 1 || flowerbed[1] == 0)) {
            n--;
            flowerbed[0] = 1;
        }
        if (flowerbed[flowerbed.length - 1] == 0 && flowerbed[flowerbed.length - 2] == 0) {
            n--;
            flowerbed[flowerbed.length - 1] = 1;
        }
        for (int i = 1; i < flowerbed.length - 1; i++) {
            if (flowerbed[i] == 0 && flowerbed[i - 1] == 0 && flowerbed[i + 1] == 0) {
                n--;
                flowerbed[i] = 1;
            }
            if (n <= 0) {
                break;
            }
        }
        return n <= 0;
    }
}
```

# 607.销售员

```sql
# Write your MySQL query statement below
select name from SalesPerson where sales_id not in (
select sales_id from Orders where com_id = (select com_id from Company where name = 'RED')
);
```

# 610.判断三角形

```sql
# Write your MySQL query statement below
select x, y, z, case when x + y > z and x + z > y and y + z > x then 'Yes' else 'No' end triangle from Triangle;
```



# 611.有效三角形的个数

```java
class Solution {
    public int triangleNumber(int[] nums) {
        Arrays.sort(nums);
        int len = nums.length;
        int result = 0;
        int j;
        int k;
        for (int i = 0; i < len; i++) {
            for (j = i + 1; j < len; j++) {
                for (k = j + 1; k < len; k++) {
                    if (nums[i] + nums[j] <= nums[k]) {
                        break;
                    }
                }
                result += k - j - 1;
            }
        }
        return result;
    }
}
```

# 619.只出现一次的最大数字

```sql
# Write your MySQL query statement below
select max(num) num from (
select num, count(*) cnt from MyNumbers group by num
) a where cnt < 2;
```

# 620.有趣的电影

```sql
# Write your MySQL query statement below
select * from cinema where id % 2 = 1 and description <> 'boring' order by rating desc;
```

# 627.变更性别

```sql
# Write your MySQL query statement below
update Salary set sex = case when sex = 'f' then 'm' else 'f' end;
```



# 628.三个数的最大乘积

```java
class Solution {
    public int maximumProduct(int[] nums) {
        Arrays.sort(nums);
        int len = nums.length;
        return Math.max(nums[len - 1] * nums[len - 2] * nums[len - 3], nums[0] * nums[1] * nums[len - 1]);
    }
}
```



# 643.子数组最大平均数Ⅰ

```java
class Solution {
    public double findMaxAverage(int[] nums, int k) {
        int sum = 0;
        int len = nums.length;
        for (int i = 0; i < k; i++) {
            sum += nums[i];
        }
        int maxSum = sum;
        for (int i = 1; i < len - k + 1; i++) {
            sum = sum - nums[i - 1] + nums[i + k - 1];
            maxSum = Math.max(maxSum, sum);
        }
        return (double) maxSum / k;
    }
}
```



# 645.错误的集合

```java
class Solution {
    public int[] findErrorNums(int[] nums) {
        Map<Integer, Integer> resultMap = new HashMap<>();
        int len = nums.length;
        int sum = (1 + len) * len / 2;
        int[] result = new int[2];
        for (int i = 0; i < len; i++) {
            int temp = resultMap.getOrDefault(nums[i], 0);
            if (temp > 0) {
                result[0] = nums[i];
                continue;
            }
            resultMap.put(nums[i], temp + 1);
            sum -= nums[i];
        }
        result[1] = sum;
        return result;
    }
}
```



# 653.两数之和Ⅳ - 输入二叉搜索树

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    List<Integer> list;
    public boolean findTarget(TreeNode root, int k) {
        list = new ArrayList<>();
        inorder(root);
        for (int i = 0; i < list.size(); i++) {
            for (int j = i + 1; j < list.size(); j++) {
                if (list.get(i) + list.get(j) == k) {
                    return true;
                }
            }
        }
        return false;
    }
    public void inorder(TreeNode node) {
        if(node == null) {
            return;
        }
        inorder(node.left);
        list.add(node.val);
        inorder(node.right);
    }
}
```

# 661.图片平滑器

```java
class Solution {
    public int[][] imageSmoother(int[][] img) {
        int m = img.length;
        int n = img[0].length;
        int[][] result = new int[m][n];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                result[i][j] = avg(img, i, j);
            }
        }
        return result;
    }

    public int avg(int[][] img, int i, int j) {
        int sum = 0;
        int num = 0;
        for (int x = i - 1; x <= i + 1; x++) {
            for (int y = j - 1; y <= j + 1; y++) {
                if (x >= 0 && y >= 0 && x < img.length && y < img[0].length) {
                    sum += img[x][y];
                    num++;
                }
            }
        }
        return sum / num;
    }
}
```

# 674.最长连续递增序列

```java
class Solution {
    public int findLengthOfLCIS(int[] nums) {
        int left = 0;
        int right = 0;
        int maxLen = 1;
        for (int i = 1; i < nums.length; i++) {
            if (nums[i] <= nums[i - 1]) {
                right = i - 1;
                maxLen = Math.max(maxLen, right - left + 1);
                left = i;
                right = i;
            }else if (i == nums.length - 1) {
                right = i;
                maxLen = Math.max(maxLen, right - left + 1);
            }
        }
        return maxLen;
    }
}
```

# 680.验证回文串Ⅱ

```java
class Solution {
    public boolean validPalindrome(String s) {
        char[] sChar = s.toCharArray();
        int left = 0;
        int right = sChar.length - 1;
        while (left < right) {
            if (sChar[left] != sChar[right]) {
                break;
            }
            left++;
            right--;
        }
        if (left >= right) {
            return true;
        }
        int temp1Left = left + 1;
        int temp1Right = right;
        int temp2Left = left;
        int temp2Right = right - 1;
        while (temp1Left < temp1Right) {
            if (sChar[temp1Left] != sChar[temp1Right]) {
                break;
            }
            temp1Left++;
            temp1Right--;
        }
        if (temp1Left >= temp1Right) {
            return true;
        }
        while (temp2Left < temp2Right) {
            if (sChar[temp2Left] != sChar[temp2Right]) {
                break;
            }
            temp2Left++;
            temp2Right--;
        }
        if (temp2Left >= temp2Right) {
            return true;
        }
        return false;
    }
}
```



# 682.棒球比赛

```java
class Solution {
    public int calPoints(String[] operations) {
        List<Integer> tempResult = new ArrayList<>();
        int sum = 0;
        for (int i = 0; i < operations.length; i++) {
            String tempString = operations[i];
            if ("C".equals(tempString)) {
                int tempInt = tempResult.get(tempResult.size() - 1);
                tempResult.remove(tempResult.size() - 1);
                sum -= tempInt;
            } else if ("D".equals(tempString)) {
                int tempInt = tempResult.get(tempResult.size() - 1) * 2;
                tempResult.add(tempInt);
                sum += tempInt;
            } else if ("+".equals(tempString)) {
                int tempInt = tempResult.get(tempResult.size() - 1) + tempResult.get(tempResult.size() - 2);
                tempResult.add(tempInt);
                sum += tempInt;
            } else {
                int tempInt = Integer.valueOf(tempString);
                tempResult.add(tempInt);
                sum += tempInt;
            }
        }
        return sum;
    }
}
```

# 696.计数二进制子串

```java
class Solution {
    public int countBinarySubstrings(String s) {
        char[] sChar = s.toCharArray();
        List<Integer> number = new ArrayList<>();
        int cnt = 0;
        for (int i = 0; i < sChar.length - 1; i++) {
            cnt++;
            if (sChar[i] != sChar[i + 1]) {
                number.add(cnt);
                cnt = 0;
            }
            if(i == sChar.length - 2) {
                if (sChar[i] == sChar[i + 1]) {
                    number.add(cnt + 1);
                } else {
                    number.add(1);
                }
            }
        }
        int result = 0;
        for (int i = 0; i < number.size() - 1; i++) {
            result += Math.min(number.get(i), number.get(i + 1));
        }
        return result;
    }
}
```



# 697.数组的度

```java
class Solution {
    public int findShortestSubArray(int[] nums) {
        Map<Integer, List<Integer>> tempMap = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            List<Integer> tempList = tempMap.getOrDefault(nums[i], new ArrayList<>());
            tempList.add(i);
            tempMap.put(nums[i], tempList);
        }
        int minLen = Integer.MAX_VALUE;
        int maxSize = 0;
        for (Integer key : tempMap.keySet()) {
            List<Integer> tempList = tempMap.get(key);
            if (tempList.size() > maxSize) {
                maxSize = tempList.size();
                minLen = tempList.get(tempList.size() - 1) - tempList.get(0) + 1;
            } else if (tempList.size() == maxSize) {
                minLen = Math.min(minLen, tempList.get(tempList.size() - 1) - tempList.get(0) + 1);
            }
        }
        return minLen;
    }
}
```



# 700.二叉搜索树中的搜索

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode searchBST(TreeNode root, int val) {
        return find(root, val);
    }
    public TreeNode find(TreeNode node, int val) {
        if (node == null) {
            return null;
        }
        if (node.val == val) {
            return node;
        } else if (node.val > val) {
            return find(node.left, val);
        } else {
            return find(node.right, val);
        }
    }
}
```

### 