# 2006.差的绝对值为K的数对数目

```java
class Solution {
    public int countKDifference(int[] nums, int k) {
        int num = 0;
        for (int i = 0; i < nums.length; i++) {
            for (int j = i + 1; j < nums.length; j++) {
                if (Math.abs(nums[i] - nums[j]) == k) {
                    num++;
                }
            }
        }
        return num;
    }
}
```



# 2011.执行操作后的变量值

```java
class Solution {
    public int finalValueAfterOperations(String[] operations) {
        int x = 0;
        for (int i = 0; i < operations.length; i++) {
            if ("++X".equals(operations[i]) || "X++".equals(operations[i])) {
                x++;
            }
            if ("--X".equals(operations[i]) || "X--".equals(operations[i])) {
                x--;
            }
        }
        return x;
    }
}
```

# 2016.增量元素之间的最大差值

```java
class Solution {
    public int maximumDifference(int[] nums) {
        int result= -1;
        for (int i = 0; i < nums.length; i++) {
            for (int j = i + 1; j < nums.length; j++) {
                if (nums[i] < nums[j]) {
                    result = Math.max(result, nums[j] - nums[i]);
                }
            }
        }
        return result;
    }
}
```



# 2022.将一维数组转变成二维数组

```java
class Solution {
    public int[][] construct2DArray(int[] original, int m, int n) {
        int len = original.length;
        if (len != m * n) {
            return new int[0][];
        }
        int k = 0;
        int[][] result = new int[m][n];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                result[i][j] = original[k++];
            }
        }
        return result;
    }
}
```

# 2027.转换字符串的最少操作次数

```java
class Solution {
    public int minimumMoves(String s) {
        int result = 0;
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) == 'X') {
                result++;
                i += 2;
            }
        }
        return result;
    }
}
```



# 2032.至少在两个数组中出现的值

```java
class Solution {
    public List<Integer> twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {
        Set<Integer> set1 = new HashSet<>();
        Set<Integer> set2 = new HashSet<>();
        Set<Integer> set3 = new HashSet<>();
        for (int i = 0; i < nums1.length; i++) {
            set1.add(nums1[i]);
        }
        for (int i = 0; i < nums2.length; i++) {
            set2.add(nums2[i]);
        }
        for (int i = 0; i < nums3.length; i++) {
            set3.add(nums3[i]);
        }
        Set<Integer> resultSet = new HashSet<>();
        for (Integer key : set1) {
            if (set2.contains(key) || set3.contains(key)) {
                resultSet.add(key);
            }
        }
        for (Integer key : set2) {
            if (set1.contains(key) || set3.contains(key)) {
                resultSet.add(key);
            }
        }
        for (Integer key : set3) {
            if (set2.contains(key) || set1.contains(key)) {
                resultSet.add(key);
            }
        }
        List<Integer> result = new ArrayList<>();
        for (Integer key : resultSet) {
            result.add(key);
        }
        return result;
    }
}
```



# 2037.使每位学生都有座位的最少移动次数

```java
class Solution {
    public int minMovesToSeat(int[] seats, int[] students) {
        heapSort(seats);
        heapSort(students);
        int len = seats.length;
        int sum = 0;
        for (int i = 0; i < len; i++) {
            sum += Math.abs(students[i] - seats[i]);
        }
        return sum;
    }
    public void swap(int[] nums, int left, int right) {
        int temp = nums[left];
        nums[left] = nums[right];
        nums[right] = temp;
    }
    public void maxHeapify(int[] nums, int left, int right) {
        int son = left * 2;
        while (son <= right) {
            if (son + 1 <= right && nums[son + 1] > nums[son]) {
                son++;
            }
            if (nums[son] > nums[left]) {
                swap(nums, son, left);
                left = son;
                son = son * 2;
            } else {
                break;
            }
        }
    }
    public void heapSort(int[] nums) {
        int len = nums.length - 1;
        for (int i = len / 2; i >= 0; i--) {
            maxHeapify(nums, i, len);
        }
        for (int i = len; i > 0; i--) {
            swap(nums, i, 0);
            maxHeapify(nums, 0, --len);
        }
    }
}
```

# 2042.检查句子中的数字是否递增

```java
class Solution {
    public boolean areNumbersAscending(String s) {
        int preInt = -1;
        String[] word = s.split(" ");
        for (int i = 0; i < word.length; i++) {
            if (Character.isDigit(word[i].charAt(0))) {
                int number = Integer.valueOf(word[i]);
                if (number <= preInt) {
                    return false;
                }
                preInt = number;
            }
        }
        return true;
    }
}
```

# 2047.句子中的有效单词数

```java
class Solution {
    public int countValidWords(String sentence) {
        Set<Character> bdSet = new HashSet<>();
        bdSet.add('!');
        bdSet.add('.');
        bdSet.add(',');
        int result = 0;
        String[] word = sentence.trim().split("\\s+");
        for (int i = 0; i < word.length; i++) {
            boolean isFalse = true;
            int lineCnt = 0;
            for (int j = 0; j < word[i].length(); j++) {
                if (Character.isDigit(word[i].charAt(j))) {
                    isFalse = false;
                    break;
                }
                if (bdSet.contains(word[i].charAt(j)) && j < word[i].length() - 1) {
                    isFalse = false;
                    break;
                }
                if (word[i].charAt(j) == '-') {
                    lineCnt++;
                    if (lineCnt > 1) {
                        isFalse = false;
                        break;
                    }
                }
                if (word[i].charAt(j) == '-' && (j == 0 || j == word[i].length() - 1 || !Character.isLetter(word[i].charAt(j - 1)) || !Character.isLetter(word[i].charAt(j + 1)) )) {
                    isFalse = false;
                    break;
                }
            }
            if (isFalse) {
                result++;
            }
        }
        return result;
    }
}
```



# 2053.数组中第K个独一无二的字符串

```java
class Solution {
    public String kthDistinct(String[] arr, int k) {
        Set<String> notOnlySet = new HashSet<>();
        Map<String, Integer> tempMap = new HashMap<>();
        for (int i = 0; i < arr.length; i++) {
            if (notOnlySet.contains(arr[i])) {
                continue;
            }
            if (tempMap.containsKey(arr[i])) {
                tempMap.remove(arr[i]);
                notOnlySet.add(arr[i]);
            } else {
                tempMap.put(arr[i], i);
            }
        }
        if (k > tempMap.size()) {
            return "";
        }
        int[] result = new int[tempMap.size()];
        int index = 0;
        Map<Integer, String> resultMap = new HashMap<>();
        for (String key : tempMap.keySet()) {
            resultMap.put(tempMap.get(key), key);
            result[index++] = tempMap.get(key);
        }
        Arrays.sort(result);
        return resultMap.get(result[k - 1]);
    }
}
```



# 2057.值相等的最小索引

```java
class Solution {
    public int smallestEqual(int[] nums) {
        for (int i = 0; i < nums.length; i++) {
            if (i % 10 == nums[i]) {
                return i;
            }
        }
        return -1;
    }
}
```



# 2058.找出临界点之间的最小和最大距离

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public int[] nodesBetweenCriticalPoints(ListNode head) {
        int minDistance = -1;
        int maxDistance = -1;
        int[] result = new int[2];
        List<Integer> indexList = new ArrayList<>();
        int index = 1;
        int prefix = head.val;
        ListNode node = head.next;
        while (node != null && node.next != null) {
            if ((node.val > prefix && node.val > node.next.val) || (node.val < prefix && node.val < node.next.val)) {
                indexList.add(index);
            }
            index++;
            prefix = node.val;
            node = node.next;
        }
        if (indexList.size() > 1) {
            maxDistance = indexList.get(indexList.size() - 1) - indexList.get(0);
            minDistance = indexList.get(1) - indexList.get(0);
            for (int i = 0; i < indexList.size() - 1; i++) {
                minDistance = Math.min(minDistance, indexList.get(i + 1) - indexList.get(i));
            }
        }
        result[0] = minDistance;
        result[1] = maxDistance;
        return result;
    }
}
```

# 2062.统计字符串中的元音子字符串

```java
class Solution {
    public int countVowelSubstrings(String word) {
        Set<Character> yuanSet = new HashSet<>();
        yuanSet.add('a');
        yuanSet.add('e');
        yuanSet.add('i');
        yuanSet.add('o');
        yuanSet.add('u');
        int result = 0;
        for (int i = 0; i < word.length(); i++) {
            if (yuanSet.contains(word.charAt(i))) {
                int[] cnt = new int[5];
                int startIndex = i;
                while (startIndex < word.length() && yuanSet.contains(word.charAt(startIndex))) {
                    char temp = word.charAt(startIndex);
                    if (temp == 'a') {
                        cnt[0]++;
                    } else if (temp == 'e') {
                        cnt[1]++;
                    } else if (temp == 'i') {
                        cnt[2]++;
                    } else if (temp == 'o') {
                        cnt[3]++;
                    } else {
                        cnt[4]++;
                    }
                    if (cnt[0] > 0 && cnt[1] > 0 && cnt[2] > 0 && cnt[3] > 0 && cnt[4] > 0) {
                        result++;
                    }
                    startIndex++;
                }
            }
        }
        return result;
    }
}
```



# 2068.检查两个字符串是否几乎相等

```java
class Solution {
    public boolean checkAlmostEquivalent(String word1, String word2) {
        Map<Character, Integer> word1Map = new HashMap<>();
        Map<Character, Integer> word2Map = new HashMap<>();
        Set<Character> wordSet = new HashSet<>();
        for (int i = 0; i < word1.length(); i++) {
            word1Map.put(word1.charAt(i), word1Map.getOrDefault(word1.charAt(i), 0) + 1);
            wordSet.add(word1.charAt(i));
        }
        for (int i = 0; i < word2.length(); i++) {
            word2Map.put(word2.charAt(i), word2Map.getOrDefault(word2.charAt(i), 0) + 1);
            wordSet.add(word2.charAt(i));
        }
        for (Character key : wordSet) {
            int cnt1 = word1Map.getOrDefault(key, 0);
            int cnt2 = word2Map.getOrDefault(key, 0);
            if (Math.abs(cnt1 - cnt2) > 3) {
                return false;
            }
        }
        return true;
    }
}
```



# 2073.买票需要的时间

```java
class Solution {
    public int timeRequiredToBuy(int[] tickets, int k) {
        int result = 0;
        for (int i = 0; i < tickets.length; i++) {
            result += tickets[i] < tickets[k] ? tickets[i] : i <= k ? tickets[k] : tickets[k] - 1;
        }
        return result;
    }
}
```



# 2074.反转偶数长度组的节点

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseEvenLengthGroups(ListNode head) {
        Stack<ListNode> stack = new Stack<>();
        ListNode newHead = new ListNode(0, head);
        ListNode node = newHead;
        int index = 0;
        while (node != null && node.next != null) {
            index++;
            int tempCount = index;
            ListNode preNode = node;
            while (tempCount > 0 && node != null && node.next != null) {
                node = node.next;
                stack.push(node);
                tempCount--;
            }
            ListNode lastNode = node.next;
            if (stack.size() % 2 == 0) {
                while (!stack.empty()) {
                    ListNode tempNode = stack.pop();
                    preNode.next = tempNode;
                    preNode = preNode.next;
                    preNode.next = lastNode;
                    node = preNode;
                }
            } else {
                stack.clear();
            }
        }
        return newHead.next;
    }
}
```

# 2078.两栋颜色不同且距离最远的房子

```java
class Solution {
    public int maxDistance(int[] colors) {
        int result = 0;
        for (int i = 0; i < colors.length; i++) {
            for (int j = i; j < colors.length; j++) {
                if (colors[i] != colors[j]) {
                    result = Math.max(Math.abs(j - i), result);
                }
            }
        }
        return result;
    }
}
```



# 2085.统计出现过一次的公共字符串

```java
class Solution {
    public int countWords(String[] words1, String[] words2) {
        Map<String, Integer> map1 = new HashMap<>();
        Map<String, Integer> map2 = new HashMap<>();
        for (int i = 0; i < words1.length; i++) {
            map1.put(words1[i], map1.getOrDefault(words1[i], 0) + 1);
        }
        for (int i = 0; i < words2.length; i++) {
            map2.put(words2[i], map2.getOrDefault(words2[i], 0) + 1);
        }
        int result = 0;
        for (String key : map1.keySet()) {
            if (map1.get(key) == 1 && map2.getOrDefault(key, 0) == 1) {
                result++;
            }
        }
        return result;
    }
}
```



# 2089.找出数组排序后的目标下标

```java
class Solution {
    public List<Integer> targetIndices(int[] nums, int target) {
        Arrays.sort(nums);
        List<Integer> result = new ArrayList<>();
        for (int i = 0; i< nums.length; i++) {
            if (!result.isEmpty() && nums[i] != target) {
                return result;
            }
            if (nums[i] == target) {
                result.add(i);
            }
        }
        return result;
    }
}
```

# 2094.找出3位偶数

```java
class Solution {
    public int[] findEvenNumbers(int[] digits) {
        Set<Integer> resultSet = new HashSet<>();
        for (int i = 0; i < digits.length; i++) {
            for (int j = 0; j < digits.length; j++) {
                for (int k = 0; k < digits.length; k++) {
                    if (digits[i] != 0 && i != j && j != k && i != k) {
                        int temp = 100 * digits[i] + 10 * digits[j] + digits[k];
                        if (temp % 2 == 0) {
                            resultSet.add(temp);
                        }
                    }
                }
            }
        }
        int[] result = new int[resultSet.size()];
        int index = 0;
        for (Integer tempInt : resultSet) {
            result[index++] = tempInt;
        }
        Arrays.sort(result);
        return result;
    }
}
```



# 2095.删除链表的中间节点

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode deleteMiddle(ListNode head) {
        ListNode newHead = new ListNode(-1, head);
        ListNode left = newHead;
        ListNode right = newHead;
        while (right.next != null && right.next.next != null) {
            left = left.next;
            right = right.next.next;
        }
        ListNode preNode = left;
        ListNode node = left.next;
        ListNode nextNode = left.next.next;
        preNode.next = nextNode;
        return newHead.next;
    }
}
```

# 2099.找到和最大的长度为K的子序列

```java
class Solution {
    public int[] maxSubsequence(int[] nums, int k) {
        int[] result = new int[k];
        int[] tempNums = new int[nums.length];
        for (int i = 0; i < nums.length; i++) {
            tempNums[i] = nums[i];
        }
        Arrays.sort(tempNums);
        Map<Integer, Integer> tempMap = new HashMap<>();
        for (int i = 0; i < tempNums.length - k; i++) {
            tempMap.put(tempNums[i], tempMap.getOrDefault(tempNums[i], 0) + 1);
        }
        int index = 0;
        for (int i = 0; i < nums.length; i++) {
            int cnt = tempMap.getOrDefault(nums[i], 0);
            if (cnt != 0) {
                tempMap.put(nums[i], cnt - 1);
            } else {
                result[index++] = nums[i];
            }
        }
        return result;
    }
}
```

