# 1704.判断字符串的两半是否相似

```java
class Solution {
    public boolean halvesAreAlike(String s) {
        char[] c = s.toCharArray();
        String h = "aeiouAEIOU";
        int len = c.length;
        int temp = 0;
        for (int i = 0; i < len / 2; i++) {
            if (h.indexOf(c[i]) >= 0) {
                temp++;
            }
        }
        for (int i = len / 2; i < len; i++) {
            if (h.indexOf(c[i]) >= 0) {
                temp--;
            }
        }
        return temp == 0;
    }
}
```

# 1710.卡车上的最大单元数

```java
class Solution {
    public int maximumUnits(int[][] boxTypes, int truckSize) {
        Arrays.sort(boxTypes, new Comparator<int[]>() {
            public int compare(int[] o1, int[] o2) {
                return o2[1] - o1[1];
            }
        });
        int result = 0;
        for (int i = 0; i < boxTypes.length; i++) {
            int size = boxTypes[i][1];
            int count = boxTypes[i][0];
            if (count < truckSize) {
                result += count * size;
                truckSize -= count;
                continue;
            } else {
                result += truckSize * size;
                return result;
            }
        }
        return result;
    }
}
```



# 1721.交换链表中的节点

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode swapNodes(ListNode head, int k) {
        ListNode newHead = new ListNode(0, head);
        ListNode left = newHead;
        ListNode right = newHead;
        while (k > 0) {
            right = right.next;
            k--;
        }
        ListNode firstNode = right;
        while (right != null) {
            left = left.next;
            right = right.next;
        }
        ListNode lastNode = left;
        int temp = firstNode.val;
        firstNode.val = lastNode.val;
        lastNode.val = temp;
        return newHead.next;
    }
}
```

