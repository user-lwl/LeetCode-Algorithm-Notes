# 1704.判断字符串的两半是否相似

```java
class Solution {
    public boolean halvesAreAlike(String s) {
        char[] c = s.toCharArray();
        String h = "aeiouAEIOU";
        int len = c.length;
        int temp = 0;
        for (int i = 0; i < len / 2; i++) {
            if (h.indexOf(c[i]) >= 0) {
                temp++;
            }
        }
        for (int i = len / 2; i < len; i++) {
            if (h.indexOf(c[i]) >= 0) {
                temp--;
            }
        }
        return temp == 0;
    }
}
```

# 1710.卡车上的最大单元数

```java
class Solution {
    public int maximumUnits(int[][] boxTypes, int truckSize) {
        Arrays.sort(boxTypes, new Comparator<int[]>() {
            public int compare(int[] o1, int[] o2) {
                return o2[1] - o1[1];
            }
        });
        int result = 0;
        for (int i = 0; i < boxTypes.length; i++) {
            int size = boxTypes[i][1];
            int count = boxTypes[i][0];
            if (count < truckSize) {
                result += count * size;
                truckSize -= count;
                continue;
            } else {
                result += truckSize * size;
                return result;
            }
        }
        return result;
    }
}
```

# 1720.解码异或后的数组

```java
class Solution {
    public int[] decode(int[] encoded, int first) {
        int[] arr = new int[encoded.length + 1];
        arr[0] = first;
        for (int i = 1; i < arr.length; i++) {
            arr[i] = arr[i - 1] ^ encoded[i - 1];
        }
        return arr;
    }
}
```



# 1721.交换链表中的节点

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode swapNodes(ListNode head, int k) {
        ListNode newHead = new ListNode(0, head);
        ListNode left = newHead;
        ListNode right = newHead;
        while (k > 0) {
            right = right.next;
            k--;
        }
        ListNode firstNode = right;
        while (right != null) {
            left = left.next;
            right = right.next;
        }
        ListNode lastNode = left;
        int temp = firstNode.val;
        firstNode.val = lastNode.val;
        lastNode.val = temp;
        return newHead.next;
    }
}
```

# 1736.替换隐藏数字得到的最晚时间

```java
class Solution {
    public String maximumTime(String time) {
        String[] timeSplit = time.split(":");
        String hour = timeSplit[0];
        String minute = timeSplit[1];
        if (hour.charAt(0) == '?' && hour.charAt(1) == '?') {
            hour = "23";
        }if (hour.charAt(0) == '?') {
            if (hour.charAt(1) <= '3') {
                hour = "2" + hour.charAt(1);
            } else {
                hour = "1" + hour.charAt(1);
            }
        }if (hour.charAt(1) == '?') {
            if (hour.charAt(0) <= '1') {
                hour = hour.charAt(0) + "9";
            } else {
                hour = hour.charAt(0) + "3";
            }
        }
        if (minute.charAt(0) == '?' && minute.charAt(1) == '?') {
            minute = "59";
        }if (minute.charAt(0) == '?') {
            minute = "5" + minute.charAt(1);
        }if (minute.charAt(1) == '?') {
            minute = minute.charAt(0) + "9";
        }
        return hour + ":" + minute;
    }
}
```



# 1742.盒子中小球的最大数量

```java
class Solution {
    public int countBalls(int lowLimit, int highLimit) {
        Map<Integer, Integer> resultMap = new HashMap<>();
        int maxNumber = 0;
        for (int i = lowLimit; i <= highLimit; i++) {
            int number = 0;
            int tempInt = i;
            while (tempInt > 0) {
                number += tempInt % 10;
                tempInt /= 10;
            }
            int cnt = resultMap.getOrDefault(number, 0) + 1;
            resultMap.put(number, cnt);
            maxNumber = Math.max(maxNumber, cnt);
        }
        return maxNumber;
    }
}
```

# 1748.唯一元素的和

```java
class Solution {
    public int sumOfUnique(int[] nums) {
        Set<Integer> onlySet = new HashSet<>();
        Set<Integer> notOnlySet = new HashSet<>();
        for (int i = 0; i < nums.length; i++) {
            if (notOnlySet.contains(nums[i])) {
                continue;
            }
            if (onlySet.contains(nums[i])) {
                onlySet.remove(nums[i]);
                notOnlySet.add(nums[i]);
                continue;
            }
            onlySet.add(nums[i]);
        }
        int result = 0;
        for (Integer key : onlySet) {
            result += key;
        }
        return result;
    }
}
```

# 1763.最长的美好子字符串

```java
class Solution {
    public String longestNiceSubstring(String s) {
        int result = 0;
        String resultString = "";
        for (int i = 0; i < s.length(); i++) {
            int lower = 0;
            int upper = 0;
            for (int j = i; j < s.length(); j++) {
                char temp = s.charAt(j);
                if (Character.isLowerCase(temp)) {
                    lower |= 1 << (temp - 'a');
                } else {
                    upper |= 1 << (temp - 'A');
                }
                if (lower == upper && j - i + 1 > result) {
                    result = j - i + 1;
                    resultString = s.substring(i, j + 1);
                }
            }
        }
        return resultString;
    }
}
```



# 1768.交替合并字符串

```java
class Solution {
    public String mergeAlternately(String word1, String word2) {
        StringBuilder sb = new StringBuilder();
        int word1Index = 0;
        int word2Index = 0;
        while (word1Index < word1.length() && word2Index < word2.length()) {
            sb.append(word1.charAt(word1Index++)).append(word2.charAt(word2Index++));
        }
        while (word1Index < word1.length()) {
            sb.append(word1.charAt(word1Index++));
        }
        while (word2Index < word2.length()) {
            sb.append(word2.charAt(word2Index++));
        }
        return sb.toString();
    }
}
```

# 1790.仅执行一次字符串交换能否使两个字符串相等

```java
class Solution {
    public boolean areAlmostEqual(String s1, String s2) {
        List<Character> s1List = new ArrayList<>();
        List<Character> s2List = new ArrayList<>();
        for (int i = 0; i < s1.length(); i++) {
            char tempChar1 = s1.charAt(i);
            char tempChar2 = s2.charAt(i);
            if (tempChar1 != tempChar2) {
                s1List.add(tempChar1);
                s2List.add(tempChar2);
            }
            if (s1List.size() > 2) {
                return false;
            }
        }
        if (s1List.size() == 0) {
            return true;
        }
        if (s1List.size() != 2) {
            return false;
        }
        if (s1List.get(0) == s2List.get(1) && s1List.get(1) == s2List.get(0)) {
            return true;
        }
        return false;
    }
}
```

