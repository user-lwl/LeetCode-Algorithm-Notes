# 3602.十六进制和三十六进制转化

```java
class Solution {
    public String concatHex36(int n) {
        int sixTen = n * n;
        int threeSixTen = n * n * n;
        return numberToSixTen(sixTen) + numberToThreeSixTen(threeSixTen);
    }
    public String numberToSixTen(int n) {
        StringBuilder sb = new StringBuilder();
        while (n > 0) {
            sb.append(numberToLetter(n % 16));
            n /= 16;
        }
        return sb.reverse().toString();
    }
    public String numberToThreeSixTen(int n) {
        StringBuilder sb = new StringBuilder();
        while (n > 0) {
            sb.append(numberToLetter(n % 36));
            n /= 36;
        }
        return sb.reverse().toString();
    }
    public String numberToLetter(int n) {
        if (n < 10) {
            return "" + n;
        } else {
            return "" + ((char) ('A' + n - 10));
        }
    }
}
```



# 3606.优惠券校验器

```java
class Solution {
    public List<String> validateCoupons(String[] code, String[] businessLine, boolean[] isActive) {
        List<String> result = new ArrayList<>();
        List<List<String>> tempResult = new ArrayList<>();
        for (int i = 0; i < 4; i++) {
            List<String> tempList = new ArrayList<>();
            tempResult.add(tempList);
        } 
        for (int i = 0; i < code.length; i++) {
            char[] tempChar = code[i].toCharArray();
            boolean isT = true;
            if (tempChar.length == 0) {
                isT = false;
            }
            for (int j = 0; j < tempChar.length; j++) {
                char tempC = tempChar[j];
                if (!((tempC >= 'a' && tempC <= 'z') || (tempC >= 'A' && tempC <= 'Z') || (tempC >= '0' && tempC <= '9') || tempC == '_')) {
                    isT = false;
                    break;
                }
            }
            String business = businessLine[i];
            if (!"electronics".equals(business) && !"grocery".equals(business) && !"pharmacy".equals(business) && !"restaurant".equals(business)) {
                isT = false;
            }
            if (isActive[i] != true) {
                isT = false;
            }
            if (isT) {
                if ("electronics".equals(business)) {
                    tempResult.get(0).add(code[i]);
                } else if ("grocery".equals(business)) {
                    tempResult.get(1).add(code[i]);
                } else if ("pharmacy".equals(business)) {
                    tempResult.get(2).add(code[i]);
                } else if ("restaurant".equals(business)) {
                    tempResult.get(3).add(code[i]);
                }
            }
        }
        Collections.sort(tempResult.get(0));
        Collections.sort(tempResult.get(1));
        Collections.sort(tempResult.get(2));
        Collections.sort(tempResult.get(3));
        result.addAll(tempResult.get(0));
        result.addAll(tempResult.get(1));
        result.addAll(tempResult.get(2));
        result.addAll(tempResult.get(3));
        return result;
    }
}
```



# 3618.根据质数下标分割数组

```java
class Solution {
    public long splitArray(int[] nums) {
        long sumA = 0;
        long sumB = 0;
        for (int i = 0; i < nums.length; i++) {
            if (isZhi(i)) {
                sumA += nums[i];
            } else {
                sumB += nums[i];
            }
        }
        return Math.abs(sumA - sumB);
    }

    public boolean isZhi(int number) {
        if (number <= 1) {
            return false;
        }
        int end = (int) Math.sqrt(number) + 1;
        for (int index = 2; index < end; index++) {
            if (number % index == 0) {
                return false;
            }
        }
        return true;
    }
}
```

# 3619.总价值可以被K整除的岛屿数目

```java
class Solution {

    boolean[][] isVisitedGrid;

    int target;

    int[][] allGrid;
    
    public int countIslands(int[][] grid, int k) {
        isVisitedGrid = new boolean[grid.length][grid[0].length];
        target = k;
        allGrid = grid;
        int gridCount = 0;
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[0].length; j++) {
                if (!isVisitedGrid[i][j] && grid[i][j] != 0) {
                    int gridSize = getGridSize(i, j);
                    if (gridSize % target == 0) {
                        gridCount++;
                    }
                }
                isVisitedGrid[i][j] = true;
            }
        }
        return gridCount;
    }

    public int getGridSize(int indexi, int indexj) {
        int thisSize = allGrid[indexi][indexj];
        if (thisSize == 0 || isVisitedGrid[indexi][indexj]) {
            return 0;
        }
        isVisitedGrid[indexi][indexj] = true;
        int topSize = 0;
        int leftSize = 0;
        int rightSize = 0;
        int bottomSize = 0;
        if (indexi > 0) {
            topSize = getGridSize(indexi - 1, indexj);
        }
        if (indexi < allGrid.length - 1) {
            bottomSize = getGridSize(indexi + 1, indexj);
        }
        if (indexj > 0) {
            leftSize = getGridSize(indexi, indexj - 1);
        }
        if (indexj < allGrid[0].length - 1) {
            rightSize = getGridSize(indexi, indexj + 1);
        }
        return thisSize + topSize + bottomSize + leftSize + rightSize;
    }
}
```

# 3622.判断整除性

```java
class Solution {
    public boolean checkDivisibility(int n) {
        int number = n;
        int sum = 0;
        int ji = 1;
        while (number > 0) {
            int tempInt = number % 10;
            number = number / 10;
            sum += tempInt;
            ji *= tempInt;
        }
        return n % (sum + ji) == 0;
    }
}
```

# 3627.中位数之和的最大值

```java
class Solution {
    public long maximumMedianSum(int[] nums) {
        Arrays.sort(nums);
        int count = 0;
        int len = nums.length;
        long sum = 0;
        for (int i = nums.length - 2; i >= 0; i -= 2) {
            if (count < len / 3) {
                sum += nums[i];
                count++;
            } else {
                return sum;
            }
        }
        return sum;
    }
}
```

# 3633.最早完成陆地和水上游乐设施的时间Ⅰ

```java
class Solution {
    public int earliestFinishTime(int[] landStartTime, int[] landDuration, int[] waterStartTime, int[] waterDuration) {
        int n = landStartTime.length;
        int[] landEndTime = new int[n];
        int m = waterStartTime.length;
        int[] waterEndTime = new int[m];
        for (int i = 0; i < n; i++) {
            landEndTime[i] = landStartTime[i] + landDuration[i];
        }
        for (int i = 0; i < m; i++) {
            waterEndTime[i] = waterStartTime[i] + waterDuration[i];
        }
        int min = Integer.MAX_VALUE;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (waterStartTime[j] >= landEndTime[i]) {
                    min = Math.min(min, waterEndTime[j]);
                } else if (landStartTime[i] >= waterEndTime[j]) {
                    min = Math.min(min, landEndTime[i]);
                } else {
                    min = Math.min(min, Math.min(waterEndTime[j] + landDuration[i], landEndTime[i] + waterDuration[j]));
                }
            }
        }
        return min;
    }
}
```

# 3643.垂直翻转子矩阵

```java
class Solution {
    public int[][] reverseSubmatrix(int[][] grid, int x, int y, int k) {
        int indexTopX = x;
        int indexTopY = y;
        int indexBottomX = x + k - 1;
        int indexBottomY = y + k - 1;
        while (indexTopX < indexBottomX) {
            for (int i = indexTopY; i <= indexBottomY; i++) {
                int temp = grid[indexTopX][i];
                grid[indexTopX][i] = grid[indexBottomX][i];
                grid[indexBottomX][i] = temp;
            }
            indexTopX++;
            indexBottomX--;
        }
        return grid;
    }
}
```

# 3658.奇数和与偶数和的最大公约数

```java
class Solution {
    public int gcdOfOddEvenSums(int n) {
        int sumOdd = (1 + (1 + 2 * (n - 1))) * n / 2;
        int sumEven = (2 + 2 * n) * n / 2;
        int result = 0;
        for (int i = 1; i <= Math.min(sumOdd, sumEven); i++) {
            if (sumOdd % i == 0 && sumEven % i == 0) {
                result = i;
            }
        }
        return result;
    }
}
```

# 3659.数组元素分组

```java
class Solution {
    public boolean partitionArray(int[] nums, int k) {
        if (nums.length % k != 0) {
            return false;
        }
        int size = nums.length / k;
        Map<Integer, Integer> tempMap = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            int cnt = tempMap.getOrDefault(nums[i], 0);
            cnt += 1;
            tempMap.put(nums[i], cnt);
            if (cnt > size) {
                return false;
            }
        }
        return true;
    }
}
```

# 3663.出现频率最低的数字

```java
class Solution {
    public int getLeastFrequentDigit(int n) {
        Map<Integer, Integer> tempMap = new HashMap<>();
        while (n > 0) {
            int tempInt = n % 10;
            n = n / 10;
            tempMap.put(tempInt, tempMap.getOrDefault(tempInt, 0) + 1);
        }
        int result = -1;
        int resultCnt = Integer.MAX_VALUE;
        for (Integer key : tempMap.keySet()) {
            int tempCnt = tempMap.get(key);
            if (tempCnt < resultCnt) {
                result = key;
                resultCnt = tempCnt;
            } else if (tempCnt == resultCnt) {
                result = Math.min(key, result);
            }
        }
        return result;
    }
}
```

# 3664.两个字母卡牌游戏

```java
class Solution {
    public int score(String[] cards, char x) {
        Map<String, Integer> first = new HashMap<>();
        Map<String, Integer> last = new HashMap<>();
        Map<String, Integer> all = new HashMap<>();
        int firstCnt = 0;
        int lastCnt = 0;
        int allCnt = 0;
        int firstMaxCnt = 0;
        int lastMaxCnt = 0;
        int allMaxCnt = 0;
        for (int i = 0; i < cards.length; i++) {
            char tempCharFirst = cards[i].charAt(0);
            char tempCharLast = cards[i].charAt(1);
            if (tempCharFirst == x && tempCharLast == x) {
                int tempCnt = all.getOrDefault(cards[i], 0) + 1;
                all.put(cards[i], tempCnt);
                allCnt++;
                allMaxCnt = Math.max(allMaxCnt, tempCnt);
            } else if (tempCharFirst == x) {
                int tempCnt = first.getOrDefault(cards[i], 0) + 1;
                first.put(cards[i], tempCnt);
                firstCnt++;
                firstMaxCnt = Math.max(firstMaxCnt, tempCnt);
            } else if (tempCharLast == x) {
                int tempCnt = last.getOrDefault(cards[i], 0) + 1;
                last.put(cards[i], tempCnt);
                lastCnt++;
                lastMaxCnt = Math.max(lastMaxCnt, tempCnt);
            }
        }
        int result = 0;
        if (firstMaxCnt <= firstCnt / 2) {
            result += firstCnt / 2;
            firstCnt %= 2;
        } else {
            result += (firstCnt - firstMaxCnt);
            firstCnt -= (firstCnt - firstMaxCnt) * 2;
        }
        if (lastMaxCnt <= lastCnt / 2) {
            result += lastCnt / 2;
            lastCnt %= 2;
        } else {
            result += (lastCnt - lastMaxCnt);
            lastCnt -= (lastCnt - lastMaxCnt) * 2;
        }
        int tempResult = result;
        int errCnt = firstCnt + lastCnt;
        if (errCnt > 0 && allCnt > 0) {
            result += Math.min(errCnt, allCnt);
            allCnt -= Math.min(errCnt, allCnt);
        }
        allCnt -= allCnt % 2;
        if (allCnt > 0) {
            result += Math.min(tempResult * 2, allCnt) / 2;
        }
        return result;
    }
}
```

# 3668.重排完成顺序

```java
class Solution {
    public int[] recoverOrder(int[] order, int[] friends) {
        Set<Integer> tempSet = new HashSet<>();
        for (int i = 0; i < friends.length; i++) {
            tempSet.add(friends[i]);
        }
        int[] result = new int[friends.length];
        int index = 0;
        for (int i = 0; i < order.length; i++) {
            if (tempSet.contains(order[i])) {
                result[index++] = order[i];
            }
        }
        return result;
    }
}
```

# 3674.数组元素相等的最小操作次数

```java
class Solution {
    public int minOperations(int[] nums) {
        Arrays.sort(nums);
        return nums[0] == nums[nums.length - 1] ? 0 : 1;
    }
}
```

# 3675.转换字符串的最小操作次数

```java
class Solution {
    public int minOperations(String s) {
        int[] tempList = new int[26];
        char[] sChar = s.toCharArray();
        for (int i = 0; i < sChar.length; i++) {
            tempList[sChar[i] - 'a']++;
        }
        int result = 0;
        for (int i = 1; i < tempList.length; i++) {
            if (tempList[i] != 0) {
                result += 26 - i;
                return result;
            }
        }
        return result;
    }
}
```

# 3678.大于平均值的最小未出现正整数

```java
class Solution {
    public int smallestAbsent(int[] nums) {
        int sum = 0;
        Set<Integer> numSet = new HashSet<>();
        for (int i = 0; i < nums.length; i++) {
            sum += nums[i];
            numSet.add(nums[i]);
        }
        int avg = sum / nums.length;
        int result = avg + 1;
        while (result < 102) {
            if (!numSet.contains(result) && result > 0) {
                return result;
            }
            result++;
        }
        return -1;
    }
}
```

# 3679.使库存平衡的最少丢弃次数

```java
class Solution {
    public int minArrivalsToDiscard(int[] arrivals, int w, int m) {
        int index = 0;
        Map<Integer, Integer> tempMap = new HashMap<>();
        int result = 0;
        int[] isRemove = new int[arrivals.length];
        for (; index < Math.min(w, arrivals.length); index++) {
            int cnt = tempMap.getOrDefault(arrivals[index], 0);
            if (cnt == m) {
                result++;
                isRemove[index] = -1;
            } else {
                tempMap.put(arrivals[index], cnt + 1);
            }
        }
        int left = 1;
        int right = index;
        while (right < arrivals.length) {
            if (isRemove[left - 1] == 0) {
                tempMap.put(arrivals[left - 1], tempMap.getOrDefault(arrivals[left - 1], 0) - 1);
            }
            int cnt = tempMap.getOrDefault(arrivals[right], 0);
            if (cnt == m) {
                result++;
                isRemove[right] = -1;
            } else {
                tempMap.put(arrivals[right], cnt + 1);
            }
            right++;
            left++;
        }
        return result;
    }
}
```

# 3683.完成一个任务的最早时间

```java
class Solution {
    public int earliestTime(int[][] tasks) {
        int result = 999;
        for (int i = 0; i < tasks.length; i++) {
            int time = tasks[i][0] + tasks[i][1];
            result = Math.min(result, time);
        }
        return result;
    }
}
```

# 3684.至多K个不同元素的最大和

```java
class Solution {
    public int[] maxKDistinct(int[] nums, int k) {
        Arrays.sort(nums);
        List<Integer> resultList = new ArrayList<>();
        Set<Integer> numberSet = new HashSet<>();
        for (int i = nums.length - 1; i >= 0; i--) {
            if (numberSet.add(nums[i])) {
                resultList.add(nums[i]);
            }
            if (resultList.size() == k) {
                break;
            }
        }
        int[] result = new int[resultList.size()];
        for (int i = 0; i < result.length; i++) {
            result[i] = resultList.get(i);
        }
        return result;
    }
}
```

# 3688.偶数的按位或运算

```java
class Solution {
    public int evenNumberBitwiseORs(int[] nums) {
        int result = 0;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] % 2 == 0) {
                result |= nums[i];
            }
        }
        return result;
    }
}
```

# 3689.最大子数组总值Ⅰ

```java
class Solution {
    public long maxTotalValue(int[] nums, int k) {
        int max = nums[0];
        int min = nums[0];
        for (int i = 0; i < nums.length; i++) {
            max = Math.max(max, nums[i]);
            min = Math.min(min, nums[i]);
        }
        return (long) k * (max - min);
    }
}
```

# 3692.众数频率字符

```java
class Solution {
    public String majorityFrequencyGroup(String s) {
        int[] cnt = new int[26];
        for (int i = 0; i < s.length(); i++) {
            cnt[s.charAt(i) - 'a']++;
        }
        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < cnt.length; i++) {
            if (cnt[i] == 0) {
                continue;
            }
            map.put(cnt[i], map.getOrDefault(cnt[i], 0) + 1);
        }
        int maxCharInt = 0;
        int maxNumber = 0;
        for (Integer key : map.keySet()) {
            if (map.get(key) > maxNumber) {
                maxCharInt = key;
                maxNumber = map.get(key);
            } else if (map.get(key) == maxNumber) {
                maxCharInt = Math.max(maxCharInt, key);
            }
        }
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < cnt.length; i++) {
            if (cnt[i] == maxCharInt) {
                sb.append((char) (i + 'a'));
            }
        }
        return sb.toString();
    }
}
```

# 3693.爬楼梯Ⅱ

```java
class Solution {
    public int climbStairs(int n, int[] costs) {
        int[] dp = new int[n];
        dp[0] = costs[0] + 1;
        if (n == 1) {
            return dp[0];
        }
        dp[1] = Math.min(dp[0] + costs[1] + 1, costs[1] + 4);
        if (n == 2) {
            return dp[1];
        }
        dp[2] = Math.min(dp[1] + costs[2] + 1, Math.min(costs[2] + 9, dp[0] + costs[2] + 4));
        for (int i = 3; i < dp.length; i++) {
            int cost1 = dp[i - 1] + costs[i] + 1;
            int cost2 = dp[i - 2] + costs[i] + 4;
            int cost3 = dp[i - 3] + costs[i] + 9;
            dp[i] = Math.min(cost1, Math.min(cost2, cost3));
        }
        return dp[n - 1];
    }
}
```

# 3697.计算十进制表示

```java
class Solution {
    public int[] decimalRepresentation(int n) {
        List<Integer> resultList = new ArrayList<>();
        int number = 1;
        while (n > 0) {
            int temp = n % 10;
            if (temp != 0) {
                resultList.add(temp * number);
            }
            n /= 10;
            number *= 10;
        }
        int[] result = new int[resultList.size()];
        for (int i = 0; i < resultList.size(); i++) {
            result[result.length - 1 - i] = resultList.get(i);
        }
        return result;
    }
}
```

# 3698.分割数组得到最小绝对差

```java
class Solution {
    public long splitArray(int[] nums) {
        int dot = -1;
        if (nums[0] >= nums[1]) {
            dot = 0;
        }
        for (int i = 0; i < nums.length - 1; i++) {
            if (dot == -1 && nums[i + 1] < nums[i]) {
                return dot;
            }
            if (dot != -1 && nums[i + 1] > nums[i]) {
                return -1;
            }
            if (nums[i] == nums[i + 1]) {
                if (i != dot) {
                    return -1;
                }
            }
            if (nums[i + 1] > nums[i] && (i + 1 == nums.length - 1 || nums[i + 2] <= nums[i + 1])) {
                dot = i + 1;
            }
        }
        if (dot == -1) {
            return -1;
        }
        long left = 0;
        long right = 0;
        for (int i = 0; i < dot; i++) {
            left += nums[i];
        }
        for (int i = dot + 1; i < nums.length; i++) {
            right += nums[i];
        }
        if (dot != nums.length - 1 && nums[dot] == nums[dot + 1]) {
            return Math.abs(right - nums[dot] - left);
        }
        return Math.min(Math.abs(right + nums[dot] - left), Math.abs(right - nums[dot] - left));
    }
}
```

