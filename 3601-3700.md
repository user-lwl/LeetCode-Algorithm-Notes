# 3618.根据质数下标分割数组

```java
class Solution {
    public long splitArray(int[] nums) {
        long sumA = 0;
        long sumB = 0;
        for (int i = 0; i < nums.length; i++) {
            if (isZhi(i)) {
                sumA += nums[i];
            } else {
                sumB += nums[i];
            }
        }
        return Math.abs(sumA - sumB);
    }

    public boolean isZhi(int number) {
        if (number <= 1) {
            return false;
        }
        int end = (int) Math.sqrt(number) + 1;
        for (int index = 2; index < end; index++) {
            if (number % index == 0) {
                return false;
            }
        }
        return true;
    }
}
```

# 3619.总价值可以被K整除的岛屿数目

```java
class Solution {

    boolean[][] isVisitedGrid;

    int target;

    int[][] allGrid;
    
    public int countIslands(int[][] grid, int k) {
        isVisitedGrid = new boolean[grid.length][grid[0].length];
        target = k;
        allGrid = grid;
        int gridCount = 0;
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[0].length; j++) {
                if (!isVisitedGrid[i][j] && grid[i][j] != 0) {
                    int gridSize = getGridSize(i, j);
                    if (gridSize % target == 0) {
                        gridCount++;
                    }
                }
                isVisitedGrid[i][j] = true;
            }
        }
        return gridCount;
    }

    public int getGridSize(int indexi, int indexj) {
        int thisSize = allGrid[indexi][indexj];
        if (thisSize == 0 || isVisitedGrid[indexi][indexj]) {
            return 0;
        }
        isVisitedGrid[indexi][indexj] = true;
        int topSize = 0;
        int leftSize = 0;
        int rightSize = 0;
        int bottomSize = 0;
        if (indexi > 0) {
            topSize = getGridSize(indexi - 1, indexj);
        }
        if (indexi < allGrid.length - 1) {
            bottomSize = getGridSize(indexi + 1, indexj);
        }
        if (indexj > 0) {
            leftSize = getGridSize(indexi, indexj - 1);
        }
        if (indexj < allGrid[0].length - 1) {
            rightSize = getGridSize(indexi, indexj + 1);
        }
        return thisSize + topSize + bottomSize + leftSize + rightSize;
    }
}
```

# 3622.判断整除性

```java
class Solution {
    public boolean checkDivisibility(int n) {
        int number = n;
        int sum = 0;
        int ji = 1;
        while (number > 0) {
            int tempInt = number % 10;
            number = number / 10;
            sum += tempInt;
            ji *= tempInt;
        }
        return n % (sum + ji) == 0;
    }
}
```

# 3627.中位数之和的最大值

```java
class Solution {
    public long maximumMedianSum(int[] nums) {
        Arrays.sort(nums);
        int count = 0;
        int len = nums.length;
        long sum = 0;
        for (int i = nums.length - 2; i >= 0; i -= 2) {
            if (count < len / 3) {
                sum += nums[i];
                count++;
            } else {
                return sum;
            }
        }
        return sum;
    }
}
```

# 3633.最早完成陆地和水上游乐设施的时间Ⅰ

```java
class Solution {
    public int earliestFinishTime(int[] landStartTime, int[] landDuration, int[] waterStartTime, int[] waterDuration) {
        int n = landStartTime.length;
        int[] landEndTime = new int[n];
        int m = waterStartTime.length;
        int[] waterEndTime = new int[m];
        for (int i = 0; i < n; i++) {
            landEndTime[i] = landStartTime[i] + landDuration[i];
        }
        for (int i = 0; i < m; i++) {
            waterEndTime[i] = waterStartTime[i] + waterDuration[i];
        }
        int min = Integer.MAX_VALUE;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (waterStartTime[j] >= landEndTime[i]) {
                    min = Math.min(min, waterEndTime[j]);
                } else if (landStartTime[i] >= waterEndTime[j]) {
                    min = Math.min(min, landEndTime[i]);
                } else {
                    min = Math.min(min, Math.min(waterEndTime[j] + landDuration[i], landEndTime[i] + waterDuration[j]));
                }
            }
        }
        return min;
    }
}
```

# 3643.垂直翻转子矩阵

```java
class Solution {
    public int[][] reverseSubmatrix(int[][] grid, int x, int y, int k) {
        int indexTopX = x;
        int indexTopY = y;
        int indexBottomX = x + k - 1;
        int indexBottomY = y + k - 1;
        while (indexTopX < indexBottomX) {
            for (int i = indexTopY; i <= indexBottomY; i++) {
                int temp = grid[indexTopX][i];
                grid[indexTopX][i] = grid[indexBottomX][i];
                grid[indexBottomX][i] = temp;
            }
            indexTopX++;
            indexBottomX--;
        }
        return grid;
    }
}
```

