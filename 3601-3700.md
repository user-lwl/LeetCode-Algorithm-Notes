# 3606.优惠券校验器

```java
class Solution {
    public List<String> validateCoupons(String[] code, String[] businessLine, boolean[] isActive) {
        List<String> result = new ArrayList<>();
        List<List<String>> tempResult = new ArrayList<>();
        for (int i = 0; i < 4; i++) {
            List<String> tempList = new ArrayList<>();
            tempResult.add(tempList);
        } 
        for (int i = 0; i < code.length; i++) {
            char[] tempChar = code[i].toCharArray();
            boolean isT = true;
            if (tempChar.length == 0) {
                isT = false;
            }
            for (int j = 0; j < tempChar.length; j++) {
                char tempC = tempChar[j];
                if (!((tempC >= 'a' && tempC <= 'z') || (tempC >= 'A' && tempC <= 'Z') || (tempC >= '0' && tempC <= '9') || tempC == '_')) {
                    isT = false;
                    break;
                }
            }
            String business = businessLine[i];
            if (!"electronics".equals(business) && !"grocery".equals(business) && !"pharmacy".equals(business) && !"restaurant".equals(business)) {
                isT = false;
            }
            if (isActive[i] != true) {
                isT = false;
            }
            if (isT) {
                if ("electronics".equals(business)) {
                    tempResult.get(0).add(code[i]);
                } else if ("grocery".equals(business)) {
                    tempResult.get(1).add(code[i]);
                } else if ("pharmacy".equals(business)) {
                    tempResult.get(2).add(code[i]);
                } else if ("restaurant".equals(business)) {
                    tempResult.get(3).add(code[i]);
                }
            }
        }
        Collections.sort(tempResult.get(0));
        Collections.sort(tempResult.get(1));
        Collections.sort(tempResult.get(2));
        Collections.sort(tempResult.get(3));
        result.addAll(tempResult.get(0));
        result.addAll(tempResult.get(1));
        result.addAll(tempResult.get(2));
        result.addAll(tempResult.get(3));
        return result;
    }
}
```



# 3618.根据质数下标分割数组

```java
class Solution {
    public long splitArray(int[] nums) {
        long sumA = 0;
        long sumB = 0;
        for (int i = 0; i < nums.length; i++) {
            if (isZhi(i)) {
                sumA += nums[i];
            } else {
                sumB += nums[i];
            }
        }
        return Math.abs(sumA - sumB);
    }

    public boolean isZhi(int number) {
        if (number <= 1) {
            return false;
        }
        int end = (int) Math.sqrt(number) + 1;
        for (int index = 2; index < end; index++) {
            if (number % index == 0) {
                return false;
            }
        }
        return true;
    }
}
```

# 3619.总价值可以被K整除的岛屿数目

```java
class Solution {

    boolean[][] isVisitedGrid;

    int target;

    int[][] allGrid;
    
    public int countIslands(int[][] grid, int k) {
        isVisitedGrid = new boolean[grid.length][grid[0].length];
        target = k;
        allGrid = grid;
        int gridCount = 0;
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[0].length; j++) {
                if (!isVisitedGrid[i][j] && grid[i][j] != 0) {
                    int gridSize = getGridSize(i, j);
                    if (gridSize % target == 0) {
                        gridCount++;
                    }
                }
                isVisitedGrid[i][j] = true;
            }
        }
        return gridCount;
    }

    public int getGridSize(int indexi, int indexj) {
        int thisSize = allGrid[indexi][indexj];
        if (thisSize == 0 || isVisitedGrid[indexi][indexj]) {
            return 0;
        }
        isVisitedGrid[indexi][indexj] = true;
        int topSize = 0;
        int leftSize = 0;
        int rightSize = 0;
        int bottomSize = 0;
        if (indexi > 0) {
            topSize = getGridSize(indexi - 1, indexj);
        }
        if (indexi < allGrid.length - 1) {
            bottomSize = getGridSize(indexi + 1, indexj);
        }
        if (indexj > 0) {
            leftSize = getGridSize(indexi, indexj - 1);
        }
        if (indexj < allGrid[0].length - 1) {
            rightSize = getGridSize(indexi, indexj + 1);
        }
        return thisSize + topSize + bottomSize + leftSize + rightSize;
    }
}
```

# 3622.判断整除性

```java
class Solution {
    public boolean checkDivisibility(int n) {
        int number = n;
        int sum = 0;
        int ji = 1;
        while (number > 0) {
            int tempInt = number % 10;
            number = number / 10;
            sum += tempInt;
            ji *= tempInt;
        }
        return n % (sum + ji) == 0;
    }
}
```

# 3627.中位数之和的最大值

```java
class Solution {
    public long maximumMedianSum(int[] nums) {
        Arrays.sort(nums);
        int count = 0;
        int len = nums.length;
        long sum = 0;
        for (int i = nums.length - 2; i >= 0; i -= 2) {
            if (count < len / 3) {
                sum += nums[i];
                count++;
            } else {
                return sum;
            }
        }
        return sum;
    }
}
```

# 3633.最早完成陆地和水上游乐设施的时间Ⅰ

```java
class Solution {
    public int earliestFinishTime(int[] landStartTime, int[] landDuration, int[] waterStartTime, int[] waterDuration) {
        int n = landStartTime.length;
        int[] landEndTime = new int[n];
        int m = waterStartTime.length;
        int[] waterEndTime = new int[m];
        for (int i = 0; i < n; i++) {
            landEndTime[i] = landStartTime[i] + landDuration[i];
        }
        for (int i = 0; i < m; i++) {
            waterEndTime[i] = waterStartTime[i] + waterDuration[i];
        }
        int min = Integer.MAX_VALUE;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (waterStartTime[j] >= landEndTime[i]) {
                    min = Math.min(min, waterEndTime[j]);
                } else if (landStartTime[i] >= waterEndTime[j]) {
                    min = Math.min(min, landEndTime[i]);
                } else {
                    min = Math.min(min, Math.min(waterEndTime[j] + landDuration[i], landEndTime[i] + waterDuration[j]));
                }
            }
        }
        return min;
    }
}
```

# 3643.垂直翻转子矩阵

```java
class Solution {
    public int[][] reverseSubmatrix(int[][] grid, int x, int y, int k) {
        int indexTopX = x;
        int indexTopY = y;
        int indexBottomX = x + k - 1;
        int indexBottomY = y + k - 1;
        while (indexTopX < indexBottomX) {
            for (int i = indexTopY; i <= indexBottomY; i++) {
                int temp = grid[indexTopX][i];
                grid[indexTopX][i] = grid[indexBottomX][i];
                grid[indexBottomX][i] = temp;
            }
            indexTopX++;
            indexBottomX--;
        }
        return grid;
    }
}
```

# 3658.奇数和与偶数和的最大公约数

```java
class Solution {
    public int gcdOfOddEvenSums(int n) {
        int sumOdd = (1 + (1 + 2 * (n - 1))) * n / 2;
        int sumEven = (2 + 2 * n) * n / 2;
        int result = 0;
        for (int i = 1; i <= Math.min(sumOdd, sumEven); i++) {
            if (sumOdd % i == 0 && sumEven % i == 0) {
                result = i;
            }
        }
        return result;
    }
}
```

# 3659.数组元素分组

```java
class Solution {
    public boolean partitionArray(int[] nums, int k) {
        if (nums.length % k != 0) {
            return false;
        }
        int size = nums.length / k;
        Map<Integer, Integer> tempMap = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            int cnt = tempMap.getOrDefault(nums[i], 0);
            cnt += 1;
            tempMap.put(nums[i], cnt);
            if (cnt > size) {
                return false;
            }
        }
        return true;
    }
}
```

# 3663.出现频率最低的数字

```java
class Solution {
    public int getLeastFrequentDigit(int n) {
        Map<Integer, Integer> tempMap = new HashMap<>();
        while (n > 0) {
            int tempInt = n % 10;
            n = n / 10;
            tempMap.put(tempInt, tempMap.getOrDefault(tempInt, 0) + 1);
        }
        int result = -1;
        int resultCnt = Integer.MAX_VALUE;
        for (Integer key : tempMap.keySet()) {
            int tempCnt = tempMap.get(key);
            if (tempCnt < resultCnt) {
                result = key;
                resultCnt = tempCnt;
            } else if (tempCnt == resultCnt) {
                result = Math.min(key, result);
            }
        }
        return result;
    }
}
```

# 3664.两个字母卡牌游戏

```java
class Solution {
    public int score(String[] cards, char x) {
        Map<String, Integer> first = new HashMap<>();
        Map<String, Integer> last = new HashMap<>();
        Map<String, Integer> all = new HashMap<>();
        int firstCnt = 0;
        int lastCnt = 0;
        int allCnt = 0;
        int firstMaxCnt = 0;
        int lastMaxCnt = 0;
        int allMaxCnt = 0;
        for (int i = 0; i < cards.length; i++) {
            char tempCharFirst = cards[i].charAt(0);
            char tempCharLast = cards[i].charAt(1);
            if (tempCharFirst == x && tempCharLast == x) {
                int tempCnt = all.getOrDefault(cards[i], 0) + 1;
                all.put(cards[i], tempCnt);
                allCnt++;
                allMaxCnt = Math.max(allMaxCnt, tempCnt);
            } else if (tempCharFirst == x) {
                int tempCnt = first.getOrDefault(cards[i], 0) + 1;
                first.put(cards[i], tempCnt);
                firstCnt++;
                firstMaxCnt = Math.max(firstMaxCnt, tempCnt);
            } else if (tempCharLast == x) {
                int tempCnt = last.getOrDefault(cards[i], 0) + 1;
                last.put(cards[i], tempCnt);
                lastCnt++;
                lastMaxCnt = Math.max(lastMaxCnt, tempCnt);
            }
        }
        int result = 0;
        if (firstMaxCnt <= firstCnt / 2) {
            result += firstCnt / 2;
            firstCnt %= 2;
        } else {
            result += (firstCnt - firstMaxCnt);
            firstCnt -= (firstCnt - firstMaxCnt) * 2;
        }
        if (lastMaxCnt <= lastCnt / 2) {
            result += lastCnt / 2;
            lastCnt %= 2;
        } else {
            result += (lastCnt - lastMaxCnt);
            lastCnt -= (lastCnt - lastMaxCnt) * 2;
        }
        int tempResult = result;
        int errCnt = firstCnt + lastCnt;
        if (errCnt > 0 && allCnt > 0) {
            result += Math.min(errCnt, allCnt);
            allCnt -= Math.min(errCnt, allCnt);
        }
        allCnt -= allCnt % 2;
        if (allCnt > 0) {
            result += Math.min(tempResult * 2, allCnt) / 2;
        }
        return result;
    }
}
```

# 3668.重排完成顺序

```java
class Solution {
    public int[] recoverOrder(int[] order, int[] friends) {
        Set<Integer> tempSet = new HashSet<>();
        for (int i = 0; i < friends.length; i++) {
            tempSet.add(friends[i]);
        }
        int[] result = new int[friends.length];
        int index = 0;
        for (int i = 0; i < order.length; i++) {
            if (tempSet.contains(order[i])) {
                result[index++] = order[i];
            }
        }
        return result;
    }
}
```

