# 703.数据流中的第K大元素

```java
class KthLargest {

    PriorityQueue<Integer> pQueue = new PriorityQueue<>();
    int size;

    public KthLargest(int k, int[] nums) {
        size = k;
        int len = nums.length;
        for (int i = 0; i < len; i++) {
            pQueue.offer(nums[i]);
        }
    }
    
    public int add(int val) {
        pQueue.offer(val);
        while (pQueue.size() > size) {
            pQueue.poll();
        }
        return pQueue.peek();
    }
}

/**
 * Your KthLargest object will be instantiated and called as such:
 * KthLargest obj = new KthLargest(k, nums);
 * int param_1 = obj.add(val);
 */
```

# 704.二分查找

```java
class Solution {
    public int search(int[] nums, int target) {
        int index = binarySearch(nums, target);
        if (index > 0 && nums[index - 1] == target) {
            return index - 1;
        }
        return -1;
    }
    public int binarySearch(int[] list, int target) {
        int left = -1;
        int right = list.length;
        while (left + 1 < right) {
            int mid = (left + right) / 2;
            if (list[mid] > target) {
                right = mid;
            } else {
                left = mid;
            }
        }
        return right;
    }
}
```

# 705.设计哈希集合

```java
class MyHashSet {
    
    int[] keySet;

    public MyHashSet() {
        keySet = new int[1000001];
    }
    
    public void add(int key) {
        keySet[key] = 1;
    }
    
    public void remove(int key) {
        keySet[key] = 0;
    }
    
    public boolean contains(int key) {
        return keySet[key] == 1;
    }
}

/**
 * Your MyHashSet object will be instantiated and called as such:
 * MyHashSet obj = new MyHashSet();
 * obj.add(key);
 * obj.remove(key);
 * boolean param_3 = obj.contains(key);
 */
```

# 706.设计哈希映射

```java
class MyHashMap {

    Integer[] keyMap;

    public MyHashMap() {
        keyMap = new Integer[1000001];
    }
    
    public void put(int key, int value) {
        keyMap[key] = value;
    }
    
    public int get(int key) {
        return keyMap[key] == null ? -1 : keyMap[key];
    }
    
    public void remove(int key) {
        keyMap[key] = null;
    }
}

/**
 * Your MyHashMap object will be instantiated and called as such:
 * MyHashMap obj = new MyHashMap();
 * obj.put(key,value);
 * int param_2 = obj.get(key);
 * obj.remove(key);
 */
```

# 717.1比特与2比特字符

```java
class Solution {
    public boolean isOneBitCharacter(int[] bits) {
        for (int i = 0; i < bits.length; i++) {
            if (i == bits.length - 1 && bits[i] == 0) {
                return true;
            }
            if (bits[i] == 1) {
                i++;
            }
        }
        return false;
    }
}
```



# 724.寻找数组的中心下标

```java
class Solution {
    int[] prefix;
    public int pivotIndex(int[] nums) {
        int len = nums.length;
        prefix = new int[len];
        prefix[0] = nums[0];
        for (int i = 1; i < len; i++) {
            prefix[i] = prefix[i - 1] + nums[i];
        }
        for (int i = 0; i < len; i++) {
            if (getPrefixSum(i - 1) == getPrefixSum(len - 1) - getPrefixSum(i)) {
                return i;
            }
        }
        return -1;
    }
    public int getPrefixSum(int index) {
        if (index == -1) {
            return 0;
        }
        return prefix[index];
    }
}
```

# 725.分隔链表

```java
 /**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode[] splitListToParts(ListNode head, int k) {
        ListNode[] result = new ListNode[k];
        if (head == null) {
            for (int i = 0; i < k; i++) {
                result[i] = head;
            }
            return result;
        }
        ListNode node = head;
        int size = 0;
        while(node != null) {
            size++;
            node = node.next;
        }
        int lenSizeFirst = (size / k) + 1;
        int lenSizeLast = (size  / k);
        int firstCount = size % k;
        node = head;
        for (int i = 0; i < firstCount; i++) {
            int temp = lenSizeFirst;
            result[i] = node;
            while (temp > 1) {
                node = node.next;
                temp--;
            }
            ListNode tempNode = node.next;
            node.next = null;
            node = tempNode;
        }
        for (int i = firstCount; i < k; i++) {
            int temp = lenSizeLast;
            result[i] = node;
            while (temp > 1) {
                node = node.next;
                temp--;
            }
            if (temp > 0) {
                ListNode tempNode = node.next;
                node.next = null;
                node = tempNode;
            }
        }
        return result;
    }
}
```

# 728.自除数

```java
class Solution {
    public List<Integer> selfDividingNumbers(int left, int right) {
        List<Integer> result = new ArrayList<>();
        for (int i = left; i <= right; i++) {
            int temp = i;
            boolean isZc = true;
            while (temp > 0) {
                int tInt = temp % 10;
                if (tInt == 0 || i % tInt != 0) {
                    isZc = false;
                    break;
                }
                temp /= 10;
            }
            if (isZc) {
                result.add(i);
            }
        }
        return result;
    }
}
```



# 733.图像渲染

```java
class Solution {

    int[][] globalImage;

    int initColor;

    public int[][] floodFill(int[][] image, int sr, int sc, int color) {
        if(image[sr][sc] == color) {
            return image;
        }
        globalImage = image;
        initColor = image[sr][sc];
        globalImage[sr][sc] = color;
        pushColor(sr, sc, color);
        return globalImage;
    }

    public void pushColor(int x, int y, int color) {
        if (x > 0 && globalImage[x - 1][y] == initColor) {
            globalImage[x - 1][y] = color;
            pushColor(x - 1, y, color);
        }
        if (x < globalImage.length - 1 && globalImage[x + 1][y] == initColor) {
            globalImage[x + 1][y] = color;
            pushColor(x + 1, y, color);
        }
        if (y > 0 && globalImage[x][y - 1] == initColor) {
            globalImage[x][y - 1] = color;
            pushColor(x, y - 1, color);
        }
        if (y < globalImage[0].length - 1 && globalImage[x][y + 1] == initColor) {
            globalImage[x][y + 1] = color;
            pushColor(x, y + 1, color);
        }
    }
}
```



# 740.删除并获得点数

```java
class Solution {
    public int deleteAndEarn(int[] nums) {
        int nlen = nums.length;
        int[] temp = new int[10001];
        int[] dp = new int[10001];
        for (int i = 0; i < nlen; i++) {
            temp[nums[i]]++;
        }
        dp[0] = temp[0];
        dp[1] = temp[1];
        for (int i = 2; i < temp.length; i++) {
            dp[i] = Math.max(dp[i - 2] + (temp[i] == 0 ? 0 : i * temp[i]), dp[i - 1]);
        }
        return dp[10000];
    }
}
```

# 744.寻找比目标字母大的最小字母

```java
class Solution {
    public char nextGreatestLetter(char[] letters, char target) {
        char result = 'z' + 1;
        for (int i = 0; i < letters.length; i++) {
            char tempChar = letters[i];
            if (tempChar > target && tempChar < result) {
                result = tempChar;
            }
        }
        return result == 'z' + 1 ? letters[0] : result;
    }
}
```



# 746.使用最小花费爬楼梯

```java
class Solution {
    public int minCostClimbingStairs(int[] cost) {
        int len = cost.length;
        int[] dp = new int[len + 1];
        dp[0] = 0;
        dp[1] = 0;
        for (int i = 2; i <= len; i++) {
            dp[i] = Math.min(dp[i - 2] + cost[i - 2], dp[i - 1] + cost[i - 1]);
        }
        return dp[len];
    }
}
```

# 747.至少是其他数字两倍的最大数

```java
class Solution {
    public int dominantIndex(int[] nums) {
        int len = nums.length;
        int max = -999;
        int maxTemp = -999;
        int maxIndex = 0;
        for (int i = 0; i < len; i++) {
            if (nums[i] > max) {
                maxTemp = max;
                max = nums[i];
                maxIndex = i;
            } else if (nums[i] > maxTemp) {
                maxTemp = nums[i];
            }
        }
        return max >= maxTemp * 2 ? maxIndex : -1;
    }
}
```

# 748.最短补全词

```java
class Solution {
    public String shortestCompletingWord(String licensePlate, String[] words) {
        Map<Character, Integer> initMap = new HashMap<>();
        char[] initCharList = licensePlate.toLowerCase().toCharArray();
        for (int i = 0; i < initCharList.length; i++) {
            if ((initCharList[i] >= '0' && initCharList[i] <= '9') || initCharList[i] == ' ') {
                continue;
            }
            initMap.put(initCharList[i], initMap.getOrDefault(initCharList[i], 0) + 1);
        }
        String result = null;
        int minLen = Integer.MAX_VALUE;
        for (int i = 0; i < words.length; i++) {
            char[] tempChar = words[i].toLowerCase().toCharArray();
            Map<Character, Integer> tempMap = new HashMap<>();
            for (int j = 0; j < tempChar.length; j++) {
                tempMap.put(tempChar[j], tempMap.getOrDefault(tempChar[j], 0) + 1);
            }
            boolean isT = true;
            for (Character key : initMap.keySet()) {
                int initCnt = initMap.get(key);
                int answerCnt = tempMap.getOrDefault(key, 0);
                if (answerCnt < initCnt) {
                    isT = false;
                    break;
                }
            }
            if (isT && words[i].length() < minLen) {
                result = words[i];
                minLen = words[i].length();
            }
        }
        return result;
    }
}
```

# 762.二进制表示中质数个计算置位

```java
class Solution {
    public int countPrimeSetBits(int left, int right) {
        int result = 0;
        for (int i = left; i <= right; i++) {
            int cnt = 0;
            for (int j = 31; j >= 0; j--) {
                if (((i >> j) & 1) == 1) {
                    cnt++;
                }
            }
            if (isZ(cnt)) {
                result++;
            }
        }
        return result;
    }
    public boolean isZ(int number) {
        if (number < 2) {
            return false;
        }
        for (int i = 2; i <= Math.sqrt(number); i++) {
            if (number % i == 0) {
                return false;
            }
        }
        return true;
    }
}
```



# 766.托普利茨矩阵

```java
class Solution {
    public boolean isToeplitzMatrix(int[][] matrix) {
        for (int i = 1; i < matrix.length; i++) {
            for (int j = 1; j < matrix[0].length; j++) {
                if (matrix[i][j] != matrix[i - 1][j - 1]) {
                    return false;
                }
            }
        }
        return true;
    }
}
```

# 771.宝石与石头

```java
class Solution {
    public int numJewelsInStones(String jewels, String stones) {
        char[] jewelsChar = jewels.toCharArray();
        char[] stonesChar = stones.toCharArray();
        Set<Character> jewelsSet = new HashSet<>();
        for (int i = 0; i < jewelsChar.length; i++) {
            jewelsSet.add(jewelsChar[i]);
        }
        int result = 0;
        for (int i = 0; i < stonesChar.length; i++) {
            if (jewelsSet.contains(stonesChar[i])) {
                result++;
            }
        }
        return result;
    }
}
```

# 796.旋转字符串

```java
class Solution {
    public boolean rotateString(String s, String goal) {
        if (s.length() != goal.length()) {
            return false;
        }
        return (s + s).indexOf(goal, 1) != -1;
    }
}
```



# 797.所有可能的路径

```java
class Solution {
    List<List<Integer>> result;
    public List<List<Integer>> allPathsSourceTarget(int[][] graph) {
        result = new ArrayList<>();
        List<Integer> res = new ArrayList<>();
        res.add(0);
        findRoad(graph, res, 0);
        return result;
    }
    public void findRoad(int[][]graph, List<Integer> list, int index) {
        if (index == graph.length - 1) {
            result.add(list);
        }
        for (int i = 0; i < graph[index].length; i++) {
            List<Integer> tempList = new ArrayList<>();
            tempList.addAll(list);
            tempList.add(graph[index][i]);
            findRoad(graph, tempList, graph[index][i]);
        }
    }
}
```

# 