# 1403.非递减顺序的最小子序列

```java
class Solution {
    public List<Integer> minSubsequence(int[] nums) {
        Arrays.sort(nums);
        int sum = 0;
        for (int i = 0; i < nums.length; i++) {
            sum += nums[i];
        }
        List<Integer> resultList = new ArrayList<>();
        int partSum = 0;
        for (int i = nums.length - 1; i >= 0; i--) {
            resultList.add(nums[i]);
            partSum += nums[i];
            sum -= nums[i];
            if (partSum > sum) {
                break;
            }
        }
        return resultList;
    }
}
```

# 1407.排名靠前的旅行者

```sql
# Write your MySQL query statement below
select a.name, ifnull(b.distance, 0) travelled_distance from Users a left join
(select user_id, sum(distance) distance from Rides group by user_id) b 
on a.id = b.user_id order by b.distance desc, a.name;
```

# 1408.数组中的字符串匹配

```java
class Solution {
    public List<String> stringMatching(String[] words) {
        List<String> result = new ArrayList<>();
        Set<String> resultSet = new HashSet<>();
        for (int i = 0; i < words.length; i++) {
            for (int j = 0; j < words.length; j++) {
                if (i == j) {
                    continue;
                }
                if (words[i].indexOf(words[j]) != -1) {
                    if (!resultSet.add(words[j])) {
                        continue;
                    }
                    result.add(words[j]);
                }
            }
        }
        return result;
    }
}
```

# 1413.逐步求和得到正数的最小值

```java
class Solution {
    public int minStartValue(int[] nums) {
        int min = 999;
        int sum = 0;
        for (int i = 0; i < nums.length; i++) {
            sum += nums[i];
            min = Math.min(min, sum);
        }
        if (min >= 1) {
            return 1;
        } else {
            return 1 - min;
        }
    }
}
```



# 1417.重新格式化字符串

```java
class Solution {
    public String reformat(String s) {
        List<Character> letterList = new ArrayList<>();
        List<Integer> numberList = new ArrayList<>();
        for (int i = 0; i < s.length(); i++) {
            char temp = s.charAt(i);
            if (Character.isLetter(temp)) {
                letterList.add(temp);
            } else {
                numberList.add(temp - '0');
            }
        }
        if (Math.abs(letterList.size() - numberList.size()) > 1)  {
            return "";
        }
        StringBuilder sb = new StringBuilder();
        int letterIndex = 0;
        int numberIndex = 0;
        while (letterIndex < letterList.size() && numberIndex < numberList.size()) {
            sb.append(letterList.get(letterIndex++)).append(numberList.get(numberIndex++));
        }
        if (letterIndex < letterList.size()){
            sb.append(letterList.get(letterIndex++));
        }
        if (numberIndex < numberList.size()) {
            sb.insert(0, numberList.get(numberIndex++));
        }
        if (numberIndex < numberList.size()) {
            sb.append(numberList.get(numberIndex++));
        }
        return sb.toString();
    }
}
```

# 1422.分割字符串的最大得分

```java
class Solution {
    public int maxScore(String s) {
        int leftZero = 0;
        int rightOne = 0;
        for (int i = 0; i < s.length(); i++) {
            if ('1' == s.charAt(i)) {
                rightOne++;
            }
        }
        int result = 0;
        for (int i = 0; i < s.length() - 1; i++) {
            if (s.charAt(i) == '1') {
                rightOne--;
            } else {
                leftZero++;
            }
            result = Math.max(result, rightOne + leftZero);
        }
        return result;
    }
}
```



# 1431.拥有最多糖果的孩子

```java
class Solution {
    public List<Boolean> kidsWithCandies(int[] candies, int extraCandies) {
        List<Boolean> result = new ArrayList<>();
        int len = candies.length;
        int max = 0;
        for (int i = 0; i < len; i++) {
            max = Math.max(max, candies[i]);
        }
        for (int i = 0; i < len; i++) {
            if (candies[i] + extraCandies >= max) {
                result.add(true);
            } else {
                result.add(false);
            }
        }
        return result;
    }
}
```

# 1436.旅行终点站

```java
class Solution {
    public String destCity(List<List<String>> paths) {
        Set<String> startSet = new HashSet<>();
        Set<String> endSet = new HashSet<>();
        for (int i = 0; i < paths.size(); i++) {
            startSet.add(paths.get(i).get(0));
            endSet.add(paths.get(i).get(1));
        }
        for (String key : endSet) {
            if (!startSet.contains(key)) {
                return key;
            }
        }
        return "";
    }
}
```

# 1437.是否所有1都至少相隔k个元素

```java
class Solution {
    public boolean kLengthApart(int[] nums, int k) {
        int preIndex = -1 * nums.length - 1;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] == 1) {
                int len = i - preIndex - 1;
                if (len < k) {
                    return false;
                }
                preIndex = i;
            }
        }
        return true;
    }
}
```



# 1438.绝对差不超过限制的最长连续子数组

```java
class Solution {
    public int longestSubarray(int[] nums, int limit) {
        int len = nums.length; 
        int result = 0;
        Deque<Integer> minQueue = new LinkedList<>();
        Deque<Integer> maxQueue = new LinkedList<>();
        int left = 0;
        for (int i = 0; i < len; i++) {
            while (!minQueue.isEmpty() && nums[i] < nums[minQueue.peekLast()]) {
                minQueue.pollLast();
            }
            while (!maxQueue.isEmpty() && nums[i] > nums[maxQueue.peekLast()]) {
                maxQueue.pollLast();
            }
            minQueue.addLast(i);
            maxQueue.addLast(i);
            while (!minQueue.isEmpty() && !maxQueue.isEmpty() && nums[maxQueue.peekFirst()] - nums[minQueue.peekFirst()] > limit) {
                if (left == minQueue.peekFirst()) {
                    minQueue.pollFirst();
                }
                if (left == maxQueue.peekFirst()) {
                    maxQueue.pollFirst();
                }
                left++;
            }
            result = Math.max(result, Math.abs(i - left) + 1);
        }
        return result;
    }
}
```

# 1439.删掉一个元素以后全为1的最长子数组

```java
class Solution {
    public int longestSubarray(int[] nums) {
        int left = 0;
        int right = 0;
        int zeroCount = 0;
        int max = 0;
        while (right < nums.length) {
            zeroCount += (nums[right] - 1) * (-1);
            while (zeroCount > 1) {
                zeroCount -= (nums[left] - 1) * (-1);
                left++;
            }
            max = Math.max(max, right - left);
            right++;
        }
        return max;
    }
}
```

# 1446.连续字符

```java
class Solution {
    public int maxPower(String s) {
        int result = 0;
        for (int i = 0; i < s.length(); i++) {
            char temp = s.charAt(i);
            int cnt = 1;
            int index = i + 1;
            while (index < s.length() && s.charAt(index) == temp) {
                cnt++;
                index++;
            }
            result = Math.max(index - i, result);
            i = index - 1;
        }
        return result;
    }
}
```

# 1450.在既定时间做作业的学生人数

```java
class Solution {
    public int busyStudent(int[] startTime, int[] endTime, int queryTime) {
        int result = 0;
        for (int i = 0; i < startTime.length; i++) {
            if (queryTime >= startTime[i] && queryTime <= endTime[i]) {
                result++;
            }
        }
        return result;
    }
}
```



# 1455.检查单词是否为句中其他单词的前缀

```java
class Solution {
    public int isPrefixOfWord(String sentence, String searchWord) {
        String[] word = sentence.split(" ");
        for (int i = 0; i < word.length; i++) {
            if (word[i].length() < searchWord.length()) {
                continue;
            }
            boolean isPre = true;
            for (int j = 0; j < searchWord.length(); j++) {
                if (word[i].charAt(j) != searchWord.charAt(j)) {
                    isPre = false;
                    break;
                }
            }
            if (isPre) {
                return i + 1;
            }
        }
        return -1;
    }
}
```



# 1460.通过翻转子数组使两个数组相等

```java
class Solution {
    public boolean canBeEqual(int[] target, int[] arr) {
        Map<Integer, Integer> resultMap = new HashMap<>();
        for (int i = 0; i < target.length; i++) {
            resultMap.put(target[i], resultMap.getOrDefault(target[i], 0) + 1);
        }
        for (int i = 0; i < arr.length; i++) {
            int cnt = resultMap.getOrDefault(arr[i], 0);
            if (cnt == 0) {
                return false;
            }
            resultMap.put(arr[i], cnt - 1);
        }
        return true;
    }
}
```



# 1464.数组中两元素的最大乘积

```java
class Solution {
    public int maxProduct(int[] nums) {
        Arrays.sort(nums);
        int len = nums.length;
        return (nums[len - 1] - 1) * (nums[len - 2] - 1);
    }
}
```

# 1470.重新排列数组

```java
class Solution {
    public int[] shuffle(int[] nums, int n) {
        int len = nums.length;
        int[] result = new int[len];
        for (int i = 0; i < len / 2; i++) {
            result[2 * i] = nums[i];
            result[2 * i + 1] = nums[i + len / 2];
        }
        return result;
    }
}
```

# 1475.商品折扣后的最终价格

```java
class Solution {
    public int[] finalPrices(int[] prices) {
        int[] result = new int[prices.length];
        for (int i = 0; i < prices.length; i++) {
            int price = prices[i];
            for (int j = i + 1; j < prices.length; j++) {
                if (prices[j] <= price) {
                    price -= prices[j];
                    break;
                }
            }
            result[i] = price;
        }
        return result;
    }
}
```



# 1480.一维数组的动态和

```java
class Solution {
    public int[] runningSum(int[] nums) {
        int len = nums.length;
        int[] result = new int[len];
        result[0] = nums[0];
        for (int i = 1; i < len; i++) {
            result[i] = result[i - 1] + nums[i];
        }
        return result;
    }
}
```

# 1484.按日期分组销售产品

```sql
# Write your MySQL query statement below
select sell_date, count(distinct product) num_sold, group_concat(distinct product order by product SEPARATOR ',') products from Activities group by sell_date order by sell_date;
```

# 1486.数组异或操作

```java
class Solution {
    public int xorOperation(int n, int start) {
        int[] nums = new int[n];
        for (int i = 0; i < nums.length; i++) {
            nums[i] = start + 2 * i;
        }
        int result = nums[0];
        for (int i = 1; i < nums.length; i++) {
            result ^= nums[i];
        }
        return result;
    }
}
```



# 1491.去掉最低工资和最高工资后的平均工资

```java
class Solution {
    public double average(int[] salary) {
        insertSort(salary);
        int sum = 0;
        int len = salary.length;
        for (int i = 1; i < len - 1; i++) {
            sum += salary[i];
        }
        return (double) sum / (len - 2);
    }
    public void insertSort(int[] a) {
        int len = a.length;
        for (int i = 1; i < a.length; i++) {
            int temp = a[i];
            int j = i - 1;
            while (j >= 0) {
                if (a[j] > temp) {
                    a[j + 1] = a[j];
                    j--;
                } else {
                    break;
                }
            }
            a[j + 1] = temp;
        }
    }
}
```

# 1492.n的第k个因子

```java
class Solution {
    public int kthFactor(int n, int k) {
        int number = 0;
        for (int i = 1; i <= n; i++) {
            if (n % i == 0) {
                number = i;
                k--;
            }
            if (k == 0) {
                return number;
            }
        }
        return -1;
    }
}
```

# 1496.判断路径是否相交

```java
class Solution {
    public boolean isPathCrossing(String path) {
        int[] draw = new int[]{0, 0};
        Set<String> dotSet = new HashSet<>();
        dotSet.add(draw[0] + " " + draw[1]);
        char[] pathChar = path.toCharArray();
        for (int i = 0; i < pathChar.length; i++) {
            char tempChar = pathChar[i];
            if (tempChar == 'N') {
                draw[1]++;
            } else if (tempChar == 'S') {
                draw[1]--;
            } else if (tempChar == 'E') {
                draw[0]++;
            } else {
                draw[0]--;
            }
            if (!dotSet.add(draw[0] + " " + draw[1])) {
                return true;
            }
        }
        return false;
    }
}
```

