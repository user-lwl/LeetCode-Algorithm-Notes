# 1403.非递减顺序的最小子序列

```java
class Solution {
    public List<Integer> minSubsequence(int[] nums) {
        Arrays.sort(nums);
        int sum = 0;
        for (int i = 0; i < nums.length; i++) {
            sum += nums[i];
        }
        List<Integer> resultList = new ArrayList<>();
        int partSum = 0;
        for (int i = nums.length - 1; i >= 0; i--) {
            resultList.add(nums[i]);
            partSum += nums[i];
            sum -= nums[i];
            if (partSum > sum) {
                break;
            }
        }
        return resultList;
    }
}
```



# 1431.拥有最多糖果的孩子

```java
class Solution {
    public List<Boolean> kidsWithCandies(int[] candies, int extraCandies) {
        List<Boolean> result = new ArrayList<>();
        int len = candies.length;
        int max = 0;
        for (int i = 0; i < len; i++) {
            max = Math.max(max, candies[i]);
        }
        for (int i = 0; i < len; i++) {
            if (candies[i] + extraCandies >= max) {
                result.add(true);
            } else {
                result.add(false);
            }
        }
        return result;
    }
}
```

# 1436.旅行终点站

```java
class Solution {
    public String destCity(List<List<String>> paths) {
        Set<String> startSet = new HashSet<>();
        Set<String> endSet = new HashSet<>();
        for (int i = 0; i < paths.size(); i++) {
            startSet.add(paths.get(i).get(0));
            endSet.add(paths.get(i).get(1));
        }
        for (String key : endSet) {
            if (!startSet.contains(key)) {
                return key;
            }
        }
        return "";
    }
}
```



# 1438.绝对差不超过限制的最长连续子数组

```java
class Solution {
    public int longestSubarray(int[] nums, int limit) {
        int len = nums.length; 
        int result = 0;
        Deque<Integer> minQueue = new LinkedList<>();
        Deque<Integer> maxQueue = new LinkedList<>();
        int left = 0;
        for (int i = 0; i < len; i++) {
            while (!minQueue.isEmpty() && nums[i] < nums[minQueue.peekLast()]) {
                minQueue.pollLast();
            }
            while (!maxQueue.isEmpty() && nums[i] > nums[maxQueue.peekLast()]) {
                maxQueue.pollLast();
            }
            minQueue.addLast(i);
            maxQueue.addLast(i);
            while (!minQueue.isEmpty() && !maxQueue.isEmpty() && nums[maxQueue.peekFirst()] - nums[minQueue.peekFirst()] > limit) {
                if (left == minQueue.peekFirst()) {
                    minQueue.pollFirst();
                }
                if (left == maxQueue.peekFirst()) {
                    maxQueue.pollFirst();
                }
                left++;
            }
            result = Math.max(result, Math.abs(i - left) + 1);
        }
        return result;
    }
}
```

# 1439.删掉一个元素以后全为1的最长子数组

```java
class Solution {
    public int longestSubarray(int[] nums) {
        int left = 0;
        int right = 0;
        int zeroCount = 0;
        int max = 0;
        while (right < nums.length) {
            zeroCount += (nums[right] - 1) * (-1);
            while (zeroCount > 1) {
                zeroCount -= (nums[left] - 1) * (-1);
                left++;
            }
            max = Math.max(max, right - left);
            right++;
        }
        return max;
    }
}
```

# 1460.通过翻转子数组使两个数组相等

```java
class Solution {
    public boolean canBeEqual(int[] target, int[] arr) {
        Map<Integer, Integer> resultMap = new HashMap<>();
        for (int i = 0; i < target.length; i++) {
            resultMap.put(target[i], resultMap.getOrDefault(target[i], 0) + 1);
        }
        for (int i = 0; i < arr.length; i++) {
            int cnt = resultMap.getOrDefault(arr[i], 0);
            if (cnt == 0) {
                return false;
            }
            resultMap.put(arr[i], cnt - 1);
        }
        return true;
    }
}
```



# 1464.数组中两元素的最大乘积

```java
class Solution {
    public int maxProduct(int[] nums) {
        Arrays.sort(nums);
        int len = nums.length;
        return (nums[len - 1] - 1) * (nums[len - 2] - 1);
    }
}
```

# 1470.重新排列数组

```java
class Solution {
    public int[] shuffle(int[] nums, int n) {
        int len = nums.length;
        int[] result = new int[len];
        for (int i = 0; i < len / 2; i++) {
            result[2 * i] = nums[i];
            result[2 * i + 1] = nums[i + len / 2];
        }
        return result;
    }
}
```

# 1480.一维数组的动态和

```java
class Solution {
    public int[] runningSum(int[] nums) {
        int len = nums.length;
        int[] result = new int[len];
        result[0] = nums[0];
        for (int i = 1; i < len; i++) {
            result[i] = result[i - 1] + nums[i];
        }
        return result;
    }
}
```

# 1491.去掉最低工资和最高工资后的平均工资

```java
class Solution {
    public double average(int[] salary) {
        insertSort(salary);
        int sum = 0;
        int len = salary.length;
        for (int i = 1; i < len - 1; i++) {
            sum += salary[i];
        }
        return (double) sum / (len - 2);
    }
    public void insertSort(int[] a) {
        int len = a.length;
        for (int i = 1; i < a.length; i++) {
            int temp = a[i];
            int j = i - 1;
            while (j >= 0) {
                if (a[j] > temp) {
                    a[j + 1] = a[j];
                    j--;
                } else {
                    break;
                }
            }
            a[j + 1] = temp;
        }
    }
}
```

# 1492.n的第k个因子

```java
class Solution {
    public int kthFactor(int n, int k) {
        int number = 0;
        for (int i = 1; i <= n; i++) {
            if (n % i == 0) {
                number = i;
                k--;
            }
            if (k == 0) {
                return number;
            }
        }
        return -1;
    }
}
```

# 1496.判断路径是否相交

```java
class Solution {
    public boolean isPathCrossing(String path) {
        int[] draw = new int[]{0, 0};
        Set<String> dotSet = new HashSet<>();
        dotSet.add(draw[0] + " " + draw[1]);
        char[] pathChar = path.toCharArray();
        for (int i = 0; i < pathChar.length; i++) {
            char tempChar = pathChar[i];
            if (tempChar == 'N') {
                draw[1]++;
            } else if (tempChar == 'S') {
                draw[1]--;
            } else if (tempChar == 'E') {
                draw[0]++;
            } else {
                draw[0]--;
            }
            if (!dotSet.add(draw[0] + " " + draw[1])) {
                return true;
            }
        }
        return false;
    }
}
```

