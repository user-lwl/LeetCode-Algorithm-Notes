# 面试题 03.01. 三合一

```java
class TripleInOne {

    int[][] stack;
    int[] index;
    int stackSizeLen;

    public TripleInOne(int stackSize) {
        stack = new int[3][stackSize];
        index = new int[3];
        stackSizeLen = stackSize;
    }
    
    public void push(int stackNum, int value) {
        if (index[stackNum] < stackSizeLen) {
            stack[stackNum][index[stackNum]++] = value;
        }
    }
    
    public int pop(int stackNum) {
        int result = -1;
        if (index[stackNum] > 0) {
            result = stack[stackNum][index[stackNum] - 1];
            index[stackNum]--;
        }
        return result;
    }
    
    public int peek(int stackNum) {
        if (index[stackNum] == 0) {
            return -1;
        }
        return stack[stackNum][index[stackNum] - 1];
    }
    
    public boolean isEmpty(int stackNum) {
        return index[stackNum] == 0;
    }
}

/**
 * Your TripleInOne object will be instantiated and called as such:
 * TripleInOne obj = new TripleInOne(stackSize);
 * obj.push(stackNum,value);
 * int param_2 = obj.pop(stackNum);
 * int param_3 = obj.peek(stackNum);
 * boolean param_4 = obj.isEmpty(stackNum);
 */
```



# 面试题 03.02.栈的最小值

```java
class MinStack {

    Stack<Integer> stack;
    Stack<Integer> minStack;

    /** initialize your data structure here. */
    public MinStack() {
        stack = new Stack<>();
        minStack = new Stack<>();
        minStack.push(Integer.MAX_VALUE);
    }
    
    public void push(int x) {
        stack.push(x);
        minStack.push(Math.min(x, minStack.peek()));
    }
    
    public void pop() {
        stack.pop();
        minStack.pop();
    }
    
    public int top() {
        return stack.peek();
    }
    
    public int getMin() {
        return minStack.peek();
    }
}

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack obj = new MinStack();
 * obj.push(x);
 * obj.pop();
 * int param_3 = obj.top();
 * int param_4 = obj.getMin();
 */
```

# 面试题 03.04.化栈为队

```java
class MyQueue {

    Stack<Integer> stack;
    Stack<Integer> stackTemp;

    /** Initialize your data structure here. */
    public MyQueue() {
        stack = new Stack<>();
        stackTemp = new Stack<>();
    }
    
    /** Push element x to the back of queue. */
    public void push(int x) {
        stack.push(x);
    }
    
    /** Removes the element from in front of queue and returns that element. */
    public int pop() {
        while (stack.size() > 0) {
            stackTemp.push(stack.pop());
        }
        int result = stackTemp.pop();
        while (stackTemp.size() > 0) {
            stack.push(stackTemp.pop());
        }
        return result;
    }
    
    /** Get the front element. */
    public int peek() {
        while (stack.size() > 0) {
            stackTemp.push(stack.pop());
        }
        int result = stackTemp.peek();
        while (stackTemp.size() > 0) {
            stack.push(stackTemp.pop());
        }
        return result;
    }
    
    /** Returns whether the queue is empty. */
    public boolean empty() {
        return stack.size() == 0;
    }
}

/**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue obj = new MyQueue();
 * obj.push(x);
 * int param_2 = obj.pop();
 * int param_3 = obj.peek();
 * boolean param_4 = obj.empty();
 */
```

# 面试题 03.06.动物收容所

```java
class AnimalShelf {

    List<LinkedList<int[]>> animalList = new ArrayList<>();
    int animalCnt = 0;

    public AnimalShelf() {
        animalList.add(new LinkedList<>());
        animalList.add(new LinkedList<>());
    }
    
    public void enqueue(int[] animal) {
        LinkedList<int[]> tempList = animalList.get(animal[1]);
        tempList.addLast(new int[]{animal[0], animalCnt++});
    }
    
    public int[] dequeueAny() {
        LinkedList<int[]> tempDogList = animalList.get(1);
        LinkedList<int[]> tempCatList = animalList.get(0);
        if (tempDogList.size() == 0) {
            return dequeueCat();
        }
        if (tempCatList.size() == 0) {
            return dequeueDog();
        }
        int[] dog = tempDogList.getFirst();
        int[] cat = tempCatList.getFirst();
        if (dog[1] < cat[1]) {
            tempDogList.removeFirst();
            return new int[]{dog[0], 1};
        } else {
            tempCatList.removeFirst();
            return new int[]{cat[0], 0};
        }
    }
    
    public int[] dequeueDog() {
        LinkedList<int[]> tempList = animalList.get(1);
        if (tempList.size() == 0) {
            return new int[]{-1, -1};
        }
        int[] dog = tempList.removeFirst();
        return new int[]{dog[0], 1};
    }
    
    public int[] dequeueCat() {
        LinkedList<int[]> tempList = animalList.get(0);
        if (tempList.size() == 0) {
            return new int[]{-1, -1};
        }
        int[] cat = tempList.removeFirst();
        return new int[]{cat[0], 0};
    }
}

/**
 * Your AnimalShelf object will be instantiated and called as such:
 * AnimalShelf obj = new AnimalShelf();
 * obj.enqueue(animal);
 * int[] param_2 = obj.dequeueAny();
 * int[] param_3 = obj.dequeueDog();
 * int[] param_4 = obj.dequeueCat();
 */
```

