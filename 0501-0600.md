# 501.二叉搜索树中的众数

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    List<Integer> result = new ArrayList<>();
    int pre = -9999;
    int count = 0;
    int maxCount = 0;
    public int[] findMode(TreeNode root) {
        inorder(root);
        int[] res = new int[result.size()];
        for (int i = 0; i < result.size(); i++) {
            res[i] = result.get(i);
        }
        return res;
    }
    public void inorder(TreeNode node) {
        if (node == null) {
            return;
        }
        inorder(node.left);
        visit(node);
        inorder(node.right);
    }
    public void visit(TreeNode node) {
        if (node.val == pre) {
            count++;
        } else {
            pre = node.val;
            count = 0;
        }
        if (count > maxCount) {
            maxCount = count;
            result = new ArrayList<>();
            result.add(node.val);
        } else if (count == maxCount) {
            result.add(node.val);
        }
    }
}
```

# 504.七进制数

```java
class Solution {
    public String convertToBase7(int num) {
        StringBuilder sb = new StringBuilder();
        String pre = "";
        if (num < 0) {
            pre = "-";
        }
        num = Math.abs(num);
        while (num > 0) {
            sb.append(num % 7);
            num /= 7;
        }
        if (sb.length() == 0) {
            sb.append(0);
        }
        return pre + sb.reverse().toString();
    }
}
```

# 506.相对名次

```java
class Solution {
    public String[] findRelativeRanks(int[] score) {
        String[] result  = new String[score.length];
        Integer[] scoreInteger = Arrays.stream(score).boxed().toArray(Integer[]::new);
        Arrays.sort(scoreInteger, Comparator.reverseOrder());
        Map<Integer, Integer> resultMap = new HashMap<>();
        int[] copyByLoop = new int[scoreInteger.length];
        for (int i = 0; i < scoreInteger.length; i++) {
            copyByLoop[i] = scoreInteger[i];
        }
        for (int i = 0; i < copyByLoop.length; i++) {
            resultMap.put(copyByLoop[i], i + 1);
        }
        for (int i = 0; i < result.length; i++) {
            Integer temp = resultMap.get(score[i]);
            if (temp == 1) {
                result[i] = "Gold Medal";
            } else if (temp == 2) {
                result[i] = "Silver Medal";
            } else if (temp == 3) {
                result[i] = "Bronze Medal";
            } else {
                result[i] = temp.toString();
            }
        }
        return result;
    }
}
```

# 507.完美数

```java
class Solution {
    public boolean checkPerfectNumber(int num) {
        if (num == 1) {
            return false;
        }
        Set<Integer> in = new HashSet<>();
        int sum = 1;
        in.add(1);
        for (int i = 2; i < num; i++) {
            if (num % i == 0) {
                if (!in.add(i)) {
                    break;
                } else {
                    sum += i;
                }
                if (!in.add(num / i)) {
                    break;
                } else {
                    sum += num / i;
                }
            }
        }
        return sum == num;
    }
}
```



# 509.斐波那契数列

```java
class Solution {
    public int fib(int n) {
        int[] num = new int[1000];
        num[0] = 0;
        num[1] = 1;
        for (int i = 2; i < n + 1; i++) {
            num[i] = num[i - 1] + num[i - 2];
        }
        return num[n];
    }
}
```

# 511.游戏玩法分析Ⅰ

```sql
# Write your MySQL query statement below
select player_id, min(event_date) first_login from Activity group by player_id order by player_id;
```

# 520.检测大写字母

```java
class Solution {
    public boolean detectCapitalUse(String word) {
        char[] wordChar = word.toCharArray();
        for (int i = 1; i < wordChar.length; i++) {
            System.out.println(wordChar[i] + " " + wordChar[i - 1]);
            if (Character.isUpperCase(wordChar[i]) && Character.isLowerCase(wordChar[i - 1])) {
                return false;
            }
            if (i > 1 && Character.isUpperCase(wordChar[i - 1]) && Character.isLowerCase(wordChar[i])) {
                return false;
            }
        }
        return true;
    }
}
```

# 521.最长特殊序列Ⅰ

```java
class Solution {
    public int findLUSlength(String a, String b) {
        if (a.equals(b)) {
            return -1;
        } 
        return Math.max(a.length(), b.length());
    }
}
```



# 525.连续数组

```java
class Solution {
    int[] prefix;
    public int findMaxLength(int[] nums) {
        int len = nums.length;
        prefix = new int[len];
        prefix[0] = nums[0];
        for (int i = 1; i < len; i++) {
            prefix[i] = prefix[i - 1] + nums[i];
        }
        // len = right - left + 1
        // 2 * (prefix[right] - prefix[left - 1]) = len = right - left + 1
        // 2 * prefix[right] - 2 * prefix[left - 1] = right - left + 1
        // 2 * prefix[right] - right = 2 * prefix[left - 1] - (left - 1)
        // x = 2 * prefix[left - 1] - (left - 1)   --用于放
        // y = 2 * prefix[right] - right           --用于取
        Map<Integer, Integer> map = new HashMap<>();
        int max = 0;
        for (int right = 0; right < len; right++) {
            // y = 2 * prefix[right] - right           --用于取
            int y = 2 * getPrefixSum(right) - right;
            int left = map.getOrDefault(y, -1);
            if (left != -1) {
                max = Math.max(max, right - left + 1);
            }
            // x = 2 * prefix[left - 1] - (left - 1)   --用于放
            int x = 2 * getPrefixSum(right - 1) - (right - 1);
            int count = map.getOrDefault(x, -1);
            if (count == -1) {
                map.put(x, right);
            }
        }
        return max;
    }
    public int getPrefixSum(int index) {
        if (index == -1) {
            return 0;
        }
        return prefix[index];
    }
}
```

# 530.二叉搜索树的最小绝对差

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    List<Integer> list;
    public int getMinimumDifference(TreeNode root) {
        list = new ArrayList<>();
        inorder(root);
        int min = Integer.MAX_VALUE;
        for (int i = 0; i < list.size() - 1; i++) {
            min = Math.min(min, list.get(i + 1) - list.get(i));
        }
        return min;
    }
    public void inorder(TreeNode node) {
        if (node == null) {
            return;
        }
        inorder(node.left);
        list.add(node.val);
        inorder(node.right);
    }
}
```

# 537.复数乘法

```java
class Solution {
    public String complexNumberMultiply(String num1, String num2) {
        String[] n1 = num1.split("\\+|i");
        String[] n2 = num2.split("\\+|i");
        int real1 = Integer.parseInt(n1[0]);
        int imag1 = Integer.parseInt(n1[1]);
        int real2 = Integer.parseInt(n2[0]);
        int imag2 = Integer.parseInt(n2[1]);
        int resultReal = real1 * real2 - imag1 * imag2;
        int resultImag = real1 * imag2 + real2 * imag1;
        return "" + resultReal + "+" + resultImag + "i";
    }
}
```

# 539.最小时间差

```java
class Solution {
    public int findMinDifference(List<String> timePoints) {
        int len = timePoints.size();
        int[] number = new int[len];
        for (int i = 0; i < len; i++) {
            String time = timePoints.get(i);
            int hour = Integer.parseInt(time.substring(0, 2));
            int min = Integer.parseInt(time.substring(3, 5));
            number[i] = 60 * hour + min;
        }
        Arrays.sort(number);
        int mini = 9999;
        for (int i = 0; i < len - 1; i++) {
            mini = mini < (number[i + 1] - number[i]) ? mini : (number[i + 1] - number[i]);
            mini = mini < (24*60 - number[i + 1] + number[i]) ? mini : (24 * 60 - number[i + 1] + number[i]);
        }
        mini = mini < (number[len - 1] - number[0]) ? mini : (number[len - 1] - number[0]);
        mini = mini < (24*60 - number[len - 1] + number[0]) ? mini : (24 * 60 - number[len - 1] + number[0]);
        return mini;
    }
}
```

# 541.反转字符串Ⅱ

```java
class Solution {
    public String reverseStr(String s, int k) {
        char[] sChar = s.toCharArray();
        for (int i = 0; i < sChar.length; i += 2 * k) {
            reversePart(sChar, i, Math.min(i + k, sChar.length) - 1);
        }
        return new String(sChar);
    }
    public void reversePart(char[] list, int left, int right) {
        while (left < right) {
            char temp = list[left];
            list[left] = list[right];
            list[right] = temp;
            left++;
            right--;
        }
    }
}
```

# 551.学生出勤记录Ⅰ

```java
class Solution {
    public boolean checkRecord(String s) {
        int absentCnt = 0;
        for (int i = 0; i < Math.min(s.length(), 2); i++) {
            if (s.charAt(i) == 'A') {
                absentCnt++;
            }
            if (absentCnt >= 2) {
                return false;
            }
        }
        for (int i = 2; i < s.length(); i++) {
            if (s.charAt(i) == 'A') {
                absentCnt++;
            }
            if (absentCnt >= 2) {
                return false;
            }
            if (s.charAt(i) == 'L' && s.charAt(i - 1) == 'L' && s.charAt(i - 2) == 'L') {
                return false;
            }
        }
        return true;
    }
}
```



# 557.反转字符串中的单词Ⅲ

```java
class Solution {
    public String reverseWords(String s) {
        String[] partString = s.split(" ");
        for (int i = 0; i < partString.length; i++) {
            partString[i] = reversePart(partString[i]);
        }
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < partString.length; i++) {
            if (!sb.isEmpty()) {
                sb.append(" ");
            }
            sb.append(partString[i]);
        }
        return sb.toString();
    }
    public String reversePart(String word) {
        char[] wordChar = word.toCharArray();
        int left = 0;
        int right = wordChar.length - 1;
        while (left < right) {
            char temp = wordChar[left];
            wordChar[left] = wordChar[right];
            wordChar[right] = temp;
            left++;
            right--;
        }
        return new String(wordChar);
    }
}
```



# 561.数组拆分

```java
class Solution {
    public int arrayPairSum(int[] nums) {
        Arrays.sort(nums);
        int sum = 0;
        for (int i = 0; i < nums.length; i+=2) {
            sum += nums[i];
        }
        return sum;
    }
}
```

# 566.重塑矩阵

```java
class Solution {
    public int[][] matrixReshape(int[][] mat, int r, int c) {
        int n = mat.length;
        int m = mat[0].length;
        if (m * n != r * c) {
            return mat;
        }
        int k = 0;
        int h = 0;
        int[][] result = new int [r][c];
        for (int i = 0; i < r; i++) {
            for (int j = 0; j < c; j++) {
                result[i][j] = mat[k][h];
                h++;
                if (h == m) {
                    k++;
                    h = 0;
                }
            }
        }
        return result;
    }
}
```

# 575.分糖果

```java
class Solution {
    public int distributeCandies(int[] candyType) {
        int len = candyType.length;
        Set<Integer> tempSet = new HashSet<>();
        for (int i = 0; i < candyType.length; i++) {
            tempSet.add(candyType[i]);
        }
        return Math.min(len / 2, tempSet.size());
    }
}
```

# 577.员工奖金

```sql
# Write your MySQL query statement below
select a.name, b.bonus from Employee a left outer join Bonus b on a.empId = b.empId where b.bonus < 1000 or b.bonus is null;
```

# 584.寻找用户推荐人

```sql
# Write your MySQL query statement below
select name from Customer where referee_id is null or referee_id <> 2;
```

# 586.订单最多的客户

```sql
# Write your MySQL query statement below
select customer_number from (
select customer_number, count(*) cnt from Orders group by customer_number
) a order by cnt desc limit 1;
```

# 589.N叉树的前序遍历

```java
/*
// Definition for a Node.
class Node {
    public int val;
    public List<Node> children;

    public Node() {}

    public Node(int _val) {
        val = _val;
    }

    public Node(int _val, List<Node> _children) {
        val = _val;
        children = _children;
    }
};
*/

class Solution {

    List<Integer> result = new ArrayList<>();

    public List<Integer> preorder(Node root) {
        getResult(root);
        return result;
    }

    public void getResult(Node node) {
        if (node == null) {
            return;
        }
        result.add(node.val);
        for (Node key : node.children) {
            getResult(key);
        }
    }
}
```

# 590.N叉树的后序遍历

```java
/*
// Definition for a Node.
class Node {
    public int val;
    public List<Node> children;

    public Node() {}

    public Node(int _val) {
        val = _val;
    }

    public Node(int _val, List<Node> _children) {
        val = _val;
        children = _children;
    }
}
*/

class Solution {

    List<Integer> result = new ArrayList<>();

    public List<Integer> postorder(Node root) {
        getResult(root);
        return result;
    }

    public void getResult(Node node) {
        if (node == null) {
            return;
        }
        for (Node key : node.children) {
            getResult(key);
        }
        result.add(node.val);
    }
}
```



# 594.最长和谐子序列

```java
class Solution {
    public int findLHS(int[] nums) {
        Map<Integer, Integer> resultMap = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            resultMap.put(nums[i], resultMap.getOrDefault(nums[i], 0) + 1);
        }
        int max = 0;
        for (Integer key : resultMap.keySet()) {
            max = Math.max(resultMap.get(key) + resultMap.getOrDefault(key + 1, -resultMap.get(key)), max);
        }
        return max;
    }
}
```

# 595.大的国家

```sql
# Write your MySQL query statement below
select name, population, area from World where area >= 3000000 or population >= 25000000;
```

# 596.超过5名学生的课

```sql
# Write your MySQL query statement below
select class from(
select class, count(*) cnt from Courses group by class
) a where a.cnt >= 5;
```



# 598.区间加法Ⅱ

```java
class Solution {
    public int maxCount(int m, int n, int[][] ops) {
        int minX = m;
        int minY = n;
        for (int i = 0; i < ops.length; i++) {
            int tempX = ops[i][0];
            int tempY = ops[i][1];
            minX = Math.min(minX, tempX);
            minY = Math.min(minY, tempY);
        }
        return minX * minY;
    }
}
```

# 599.两个列表的最小索引总和

```java
class Solution {
    public String[] findRestaurant(String[] list1, String[] list2) {
        Map<String, Integer> temp1Map = new HashMap<>();
        Map<String, Integer> temp2Map = new HashMap<>();
        for (int i = 0; i < list1.length; i++) {
            temp1Map.put(list1[i], i);
        }
        for (int i = 0; i < list2.length; i++) {
            temp2Map.put(list2[i], i);
        }
        int minResult = Integer.MAX_VALUE;
        List<String> result = new ArrayList<>();
        for (String key : temp1Map.keySet()) {
            Integer tempIndex1 = temp1Map.get(key);
            Integer tempIndex2 = temp2Map.getOrDefault(key, null);
            if (tempIndex2 != null) {
                int sum = tempIndex1 + tempIndex2;
                if (sum < minResult) {
                    minResult = sum;
                    result = new ArrayList<>();
                    result.add(key);
                } else if (sum == minResult) {
                    result.add(key);
                }
            }
        }
        String[] resultList = new String[result.size()];
        for (int i = 0; i < result.size(); i++) {
            resultList[i] = result.get(i);
        }
        return resultList;
    }
}
```

