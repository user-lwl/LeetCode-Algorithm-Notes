# 404.左叶子之和

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {

    int sum;

    public int sumOfLeftLeaves(TreeNode root) {
        sum = 0;
        getSumLeft(root);
        return sum;
    }

    public void getSumLeft(TreeNode node) {
        if (node == null) {
            return;
        }
        if (node.left != null && node.left.left == null && node.left.right == null) {
            sum += node.left.val;
        }
        getSumLeft(node.left);
        getSumLeft(node.right);
    }
}
```

# 409.最长回文串

```java
class Solution {
    public int longestPalindrome(String s) {
        char[] sChar = s.toCharArray();
        Map<Character, Integer> tempMap = new HashMap<>();
        for (int i = 0; i < sChar.length; i++) {
            tempMap.put(sChar[i], tempMap.getOrDefault(sChar[i], 0) + 1);
        }
        int result = 0;
        int isHaveNumber = 0;
        for (Character tempChar : tempMap.keySet()) {
            int cnt = tempMap.get(tempChar);
            result += cnt / 2 * 2;
            isHaveNumber += cnt % 2;
        }
        return isHaveNumber > 0 ? result + 1 : result;
    }
}
```



# 410.分割数组的最大值

```java
class Solution {
    public int splitArray(int[] nums, int k) {
        int left = 0;
        int right = 1000000000;
        int result = -1;
        while (left <= right) {
            int mid = (left + right) / 2;
            if (check(nums, k, mid)) {
                result = mid;
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        return result;
    }
    public boolean check(int[] nums, int k, int number) {
        int sum = 0;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] > number) {
                return false;
            }
            sum += nums[i];
            if (sum > number) {
                sum = nums[i];
                k--;
                if (k == 0) {
                    return false;
                }
            }
        }
        return true;
    }
}
```

# 414.第三大的数

```java
class Solution {
    public int thirdMax(int[] nums) {
        long max = Long.MIN_VALUE;
        long second = Long.MIN_VALUE;
        long thrid = Long.MIN_VALUE;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] > max) {
                thrid = second;
                second = max;
                max = nums[i];
            } else if (nums[i] > second && nums[i] < max) {
                thrid = second;
                second = nums[i];
            } else if (nums[i] > thrid && nums[i] < second) {
                thrid = nums[i];
            }
        }
        return thrid == Long.MIN_VALUE ? (int) max: (int) thrid;
    }
}
```

# 416.分割等和子集

```java
class Solution {
    public boolean canPartition(int[] nums) {
        int[][] dp = new int[201][20001];
        dp[0][0] = 1;
        dp[0][nums[0]] = 1;
        int sum = nums[0];
        int len = nums.length;
        for (int i = 1; i < len; i++) {
            sum += nums[i];
            for (int j = 0; j <= sum; j++) {
                dp[i][j] = dp[i - 1][j];
                if (j - nums[i] >= 0) {
                    dp[i][j] |= dp[i - 1][j - nums[i]];
                }
            }
        }
        if (sum % 2 == 1) {
            return false;
        }
        return dp[len - 1][sum / 2] == 1;
    }
}
```

# 430.扁平化多级双向链表

```java
/*
// Definition for a Node.
class Node {
    public int val;
    public Node prev;
    public Node next;
    public Node child;
};
*/

class Solution {
    public Node flatten(Node head) {
        if (head == null) {
            return head;
        }
        flattenList(head);
        return head;
    }
    public Node flattenList(Node head) {
        Node node = head;
        Node result = head;
        while (node != null) {
            if (node.child != null) {
                Node nextNode = node.next;
                Node tempHead = node.child;
                Node tempTail = flattenList(tempHead);
                node.next = tempHead;
                tempHead.prev = node;
                tempTail.next = nextNode;
                node.child = null;
                if (nextNode != null) {
                    nextNode.prev = tempTail;
                }
            }
            if (node.next == null) {
                result = node;
            }
            node = node.next;
        }
        return result;
    }
}
```

# 434.字符串中的单词数

```java
class Solution {
    public int countSegments(String s) {
        char[] c = s.toCharArray();
        int number = 0;
        for (int i = 0; i < c.length; i++) {
            if ((i == 0 || c[i - 1] == ' ') && c[i] != ' ') {
                number++;
            }
        }
        return number;
    }
}
```

# 441.排列硬币

```java
class Solution {
    public int arrangeCoins(int n) {
        // 1 -> 1
        // 2 -> 3
        // 3 -> 6
        // x -> x(x + 1) / 2
        // 等差数列
        return binarySearch(n) - 1;
    }
    public int binarySearch(int n) {
        long left = -1;
        long right = (long)n + 1;
        while (left + 1 < right) {
            long mid = (left + right) / 2;
            if (mid * (mid + 1) / 2 > n) {
                right = mid;
            } else {
                left = mid;
            }
        }
        return (int)right;
    }
}
```

# 445.两数相加Ⅱ

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        Stack<ListNode> stack1 = new Stack<>();
        Stack<ListNode> stack2 = new Stack<>();
        while (l1 != null) {
            stack1.push(l1);
            l1= l1.next;
        }
        while(l2 != null) {
            stack2.push(l2);
            l2 = l2.next;
        }
        if (stack1.size() < stack2.size()) {
            Stack<ListNode> tempStack = stack1;
            stack1 = stack2;
            stack2 = tempStack;
        }
        int isNext = 0;
        ListNode newHead = null;
        while(!stack1.empty() && !stack2.empty()) {
            ListNode tempNode1 = stack1.pop();
            ListNode tempNode2 = stack2.pop();
            int val = (tempNode1.val + tempNode2.val + isNext) % 10;
            isNext = (tempNode1.val + tempNode2.val + isNext) / 10;
            tempNode1.val = val;
            newHead = tempNode1;
        }
        while (!stack1.empty()) {
            ListNode tempNode1 = stack1.pop();
            int val = (tempNode1.val + isNext) % 10;
            isNext = (tempNode1.val + isNext) / 10;
            tempNode1.val = val;
            newHead = tempNode1;
        }
        if (isNext != 0) {
            ListNode node = new ListNode(isNext);
            node.next = newHead;
            newHead = node;
        }
        return newHead;
    }
}
```

# 448.找到所有数组中消失的数字

```java
class Solution {
    public List<Integer> findDisappearedNumbers(int[] nums) {
        int len = nums.length;
        int[] tempList = new int[len + 1];
        for (int i = 0; i < nums.length; i++) {
            tempList[nums[i]]++;
        }
        List<Integer> result = new ArrayList<>();
        for (int i = 1; i < tempList.length; i++) {
            if (tempList[i] == 0) {
                result.add(i);
            }
        }
        return result;
    }
}
```



# 450.删除二叉搜索树中的节点

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode deleteNode(TreeNode root, int key) {
        if(root == null) {
            return null;
        }
        if (root.val > key) {
            root.left = deleteNode(root.left, key);
        } else if (root.val < key) {
            root.right = deleteNode(root.right, key);
        } else {
            return delete(root);
        }
        return root;
    }
    public TreeNode delete(TreeNode node) {
        if (node.left == null) {
            return node.right;
        } else if (node.right == null) {
            return node.left;
        } else {
            int min = findMin(node.right); 
            TreeNode temp = new TreeNode();
            node.right = deleteNode(node.right, min);
            temp.val = min;
            temp.left = node.left;
            temp.right = node.right;
            return temp;
        }
    }
    public int findMin(TreeNode node) {
        if (node.left == null) {
            return node.val;
        } else {
            return findMin(node.left);
        }
    }
}
```

# 455.分发饼干

```java
class Solution {
    public int findContentChildren(int[] g, int[] s) {
        Arrays.sort(g);
        Arrays.sort(s);
        int glen = g.length;
        int slen = s.length;
        int result = 0;
        int stemp = 0;
        int gtemp = 0;
        while (stemp < slen && gtemp < glen) {
            if (s[stemp] >= g[gtemp]) {
                result++;
                stemp++;
                gtemp++;
            } else {
                stemp++;
            }
        }
        return result;
    }
}
```

# 463.岛屿的周长

```java
class Solution {
    public int islandPerimeter(int[][] grid) {
        int cnt = 0;
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[0].length; j++) {
                if (grid[i][j] == 1) {
                    if (i == 0 || grid[i - 1][j] == 0) {
                        cnt++;
                    }
                    if (i == grid.length - 1 || grid[i + 1][j] == 0) {
                        cnt++;
                    }
                    if (j == 0 || grid[i][j - 1] == 0) {
                        cnt++;
                    }
                    if (j == grid[0].length - 1 || grid[i][j + 1] == 0) {
                        cnt++;
                    }
                }
            }
        }
        return cnt;
    }
}
```



# 485.最大连续1的个数

```java
class Solution {
    public int findMaxConsecutiveOnes(int[] nums) {
        int max = 0;
        int temp = 0;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] == 1) {
                temp++;
            }
            if (nums[i] == 0 || i == nums.length - 1) {
                max = Math.max(max, temp);
                temp = 0;
            }
        }
        return max;
    }
}
```

# 495.提莫攻击

```java
class Solution {
    public int findPoisonedDuration(int[] timeSeries, int duration) {
        int result = duration;
        int pre = timeSeries[0] + duration - 1;
        for (int i = 1; i < timeSeries.length; i++) {
            if (pre >= timeSeries[i]) {
                result += timeSeries[i] + duration - 1 - pre;
            } else {
                result += duration;
            }
            pre = timeSeries[i] + duration - 1;
        }
        return result;
    }
}
```

# 496.下一个更大元素Ⅰ

```java
class Solution {
    public int[] nextGreaterElement(int[] nums1, int[] nums2) {
        Map<Integer, Integer> tempMap = new HashMap<>();
        for (int i = 0; i < nums2.length; i++) {
            tempMap.put(nums2[i], i);
        }
        int[] result = new int[nums1.length];
        for (int i = 0; i < nums1.length; i++){
            int index = tempMap.get(nums1[i]);
            int tempResult = -1;
            for (int j = index; j < nums2.length; j++) {
                if(nums2[j] > nums1[i]) {
                    tempResult = nums2[j];
                    break;
                }
            }
            result[i] = tempResult;
        }
        return result;
    }
}
```

# 500.键盘行

```java
class Solution {
    public String[] findWords(String[] words) {
        List<String> tempResult = new ArrayList<>();
        Set<Character> temp1Set = new HashSet<>();
        Set<Character> temp2Set = new HashSet<>();
        Set<Character> temp3Set = new HashSet<>();
        temp1Set.add('q');
        temp1Set.add('w');
        temp1Set.add('e');
        temp1Set.add('r');
        temp1Set.add('t');
        temp1Set.add('y');
        temp1Set.add('u');
        temp1Set.add('i');
        temp1Set.add('o');
        temp1Set.add('p');
        temp2Set.add('a');
        temp2Set.add('s');
        temp2Set.add('d');
        temp2Set.add('f');
        temp2Set.add('g');
        temp2Set.add('h');
        temp2Set.add('j');
        temp2Set.add('k');
        temp2Set.add('l');
        temp3Set.add('z');
        temp3Set.add('x');
        temp3Set.add('c');
        temp3Set.add('v');
        temp3Set.add('b');
        temp3Set.add('n');
        temp3Set.add('m');
        for (int i = 0; i < words.length; i++) {
            String tempString = words[i].toLowerCase();
            char[] tempChar = tempString.toCharArray();
            int temp1Cnt = 0;
            int temp2Cnt = 0;
            int temp3Cnt = 0;
            for (int j = 0; j < tempChar.length; j++) {
                char tempC = tempChar[j];
                if (temp1Set.contains(tempC)) {
                    temp1Cnt++;
                } else if (temp2Set.contains(tempC)) {
                    temp2Cnt++;
                } else if (temp3Set.contains(tempC)) {
                    temp3Cnt++;
                }
            }
            if ((temp1Cnt == 0 && temp2Cnt == 0) || (temp1Cnt == 0 && temp3Cnt == 0) || (temp3Cnt == 0 && temp2Cnt == 0)) {
                tempResult.add(words[i]);
            }
        }
        String[] result = new String[tempResult.size()];
        for (int i = 0; i < tempResult.size(); i++) {
            result[i] = tempResult.get(i);
        }
        return result;
    }
}
```

