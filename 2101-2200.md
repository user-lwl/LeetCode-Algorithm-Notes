# 2103.环和杆

```java
class Solution {
    public int countPoints(String rings) {
        List<Set<Character>> resultList = new ArrayList<>();
        for (int i = 0; i < 10; i++) {
            resultList.add(new HashSet<>());
        }
        for (int i = 0; i < rings.length(); i+= 2) {
            char color = rings.charAt(i);
            int number = rings.charAt(i + 1) - '0';
            Set<Character> tempSet = resultList.get(number);
            tempSet.add(color);
        }
        int result = 0;
        for (int i = 0; i < 10; i++) {
            Set<Character> tempSet = resultList.get(i);
            if (tempSet.size() == 3) {
                result++;
            }
        }
        return result;
    }
}
```



# 2108.找出数组中的第一个回文字符串

```java
class Solution {
    public String firstPalindrome(String[] words) {
        for (int i = 0; i < words.length; i++) {
            StringBuilder sb = new StringBuilder();
            for (int j = words[i].length() - 1; j >= 0; j--) {
                sb.append(words[i].charAt(j));
            }
            if (words[i].equals(sb.toString())) {
                return words[i];
            }
        }
        return "";
    }
}
```

```java
class Solution {
    public String firstPalindrome(String[] words) {
        for (int i = 0; i < words.length; i++) {
            boolean isHv = true;
            int left = 0;
            int right = words[i].length() - 1;
            while (left < right) {
                if (words[i].charAt(left) != words[i].charAt(right)) {
                    isHv = false;
                    break;
                }
                left++;
                right--;
            }
            if (isHv) {
                return words[i];
            }
        }
        return "";
    }
}
```



# 2109.向字符串添加空格

```java
class Solution {
    public String addSpaces(String s, int[] spaces) {
        char[] ch = s.toCharArray();
        int index = 0;
        StringBuilder result = new StringBuilder();
        for (int i = 0; i < ch.length; i++) {
            if (index < spaces.length && i == spaces[index]) {
                result.append(" ");
                index++;
            }
            result.append(ch[i]);
        }
        return result.toString();
    }
}
```

# 2114.句子中的最多单词数

```java
class Solution {
    public int mostWordsFound(String[] sentences) {
        int max = 0;
        for (int i = 0; i < sentences.length; i++) {
            int temp = 0;
            for (int j = 0; j < sentences[i].length(); j++) {
                if (sentences[i].charAt(j) == ' ') {
                    temp++;
                }
            }
            max = Math.max(max, temp + 1);
        }
        return max;
    }
}
```

# 2119.反转两次的数字

```java
class Solution {
    public boolean isSameAfterReversals(int num) {
        if (num == 0) {
            return true;
        }
        while (num % 10 == 0) {
            return false;
        }
        return true;
    }
}
```

# 2124.检查是否所有A都在B之前

```java
class Solution {
    public boolean checkString(String s) {
        boolean isB = false;
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) == 'b') {
                isB = true;
            }
            if (isB && s.charAt(i) == 'a') {
                return false;
            }
        }
        return true;
    }
}
```

```java
class Solution {
    public boolean checkString(String s) {
        char[] sChar = s.toCharArray();
        Arrays.sort(sChar);
        return s.equals(new String(sChar));
    }
}
```



# 2129.将标题首字母大写

```java
class Solution {
    public String capitalizeTitle(String title) {
        StringBuilder result = new StringBuilder();
        for (String s : title.split(" ")) {
            if (!result.isEmpty()) {
                result.append(' ');
            }
            if (s.length() >= 3) {
                result.append(s.substring(0, 1).toUpperCase());
                result.append(s.substring(1).toLowerCase());
            } else {
                result.append(s.toLowerCase());
            }
        }
        return result.toString();
    }
}
```

# 2130.链表最大孪生和

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public int pairSum(ListNode head) {
        Deque<ListNode> queue = new LinkedList<>();
        int max = 0;
        while (head != null) {
            queue.add(head);
            head = head.next;
        }
        while (!queue.isEmpty()) {
            ListNode node1 = queue.pollFirst();
            ListNode node2 = queue.pollLast();
            max = Math.max(max, node1.val + node2.val);
        }
        return max;
    }
}
```

# 2133.检查是否每一行每一列都包含全部整数

```java
class Solution {
    public boolean checkValid(int[][] matrix) {
        List<Set<Integer>> lieList = new ArrayList<>();
        List<Set<Integer>> hangList = new ArrayList<>();
        for (int i = 0; i < matrix.length; i++) {
            lieList.add(new HashSet<>());
            hangList.add(new HashSet<>());
        }
        for (int i = 0; i < matrix.length; i++) {
            for (int j = 0; j < matrix[0].length; j++) {
                Set<Integer> lieSet = lieList.get(j);
                Set<Integer> hangSet = hangList.get(i);
                if (!lieSet.add(matrix[i][j]) || !hangSet.add(matrix[i][j])) {
                    return false;
                }
            }
        }
        return true;
    }
}
```

# 2138.将字符串拆分为若干长度为k的组

```java
class Solution {
    public String[] divideString(String s, int k, char fill) {
        String[] result = new String[(s.length() + (k - 1)) / k];
        for (int i = 0; i < k; i++) {
            s += fill;
        }
        int index = 0;
        for (int i = 0; i < s.length() - k; i += k) {
            StringBuilder sb = new StringBuilder();
            for (int j = 0; j < k; j++) {
                sb.append(s.charAt(i + j));
            }
            result[index++] = sb.toString();
        }
        return result;
    }
}
```



# 2144.打折购买糖果的最小开销

```java
class Solution {
    public int minimumCost(int[] cost) {
        Arrays.sort(cost);
        int indexX = cost.length - 1;
        int indexY = cost.length - 2;
        int result = 0;
        while (indexX >=0 && indexY >= 0) {
            result += cost[indexX]  + cost[indexY];
            indexX -= 3;
            indexY -= 3;
        }
        if (indexX >= 0) {
            result += cost[indexX];
        }
        if (indexY >= 0) {
            result += cost[indexY];
        }
        return result;
    }
}
```



# 2148.元素计数

```java
class Solution {
    public int countElements(int[] nums) {
        bubblSort(nums);
        int number = 0;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] > nums[0] && nums[i] < nums[nums.length - 1]) {
                number++;
            }
        }
        return number;
    }
    public void bubblSort(int[] nums) {
        int n = nums.length;
        for (int i = n - 1; i > 0; i--) {
            for (int j = 0; j < i; j++) {
                if (nums[j] > nums[i]) {
                    int temp = nums[j];
                    nums[j] = nums[i];
                    nums[i] = temp;
                }
            }
        }
    }
}
```

# 2154.将找到的值乘以2

```java
class Solution {
    public int findFinalValue(int[] nums, int original) {
        Set<Integer> resultSet = new HashSet<>();
        for (int i = 0; i < nums.length; i++) {
            resultSet.add(nums[i]);
        }
        while (resultSet.contains(original)) {
            original *= 2;
        }
        return original;
    }
}
```

# 2160.拆分数位后四位数字的最小和

```java
class Solution {
    public int minimumSum(int num) {
        int[] cntList = new int[10];
        while (num > 0) {
            int number = num % 10;
            num /= 10;
            cntList[number]++;
        }
        int cnt = 2;
        int sum = 0;
        for (int i = 0; i < cntList.length; i++) {
            if (cntList[i] > 0) {
                if (cnt >= cntList[i]) {
                    sum += i * 10 * cntList[i];
                    cnt -= cntList[i];
                } else {
                    sum += i * 10 * cnt + i * (cntList[i] - cnt);
                    cnt = 0;
                }
            }
        }
        return sum;
    }
}
```

# 2164.对奇偶下标分别排序

```java
class Solution {
    public int[] sortEvenOdd(int[] nums) {
        Integer[] jiList = new Integer[nums.length / 2];
        Integer[] ouList = new Integer[nums.length / 2 + nums.length % 2];
        int jiIndex = 0;
        int ouIndex = 0;
        for (int i = 0; i < nums.length; i++) {
            if (i % 2 == 0) {
                ouList[ouIndex++] = nums[i];
            } else {
                jiList[jiIndex++] = nums[i];
            }
        }
        Arrays.sort(jiList, Collections.reverseOrder());
        Arrays.sort(ouList);
        jiIndex = 0;
        ouIndex = 0;
        for (int i = 0; i < nums.length; i++) {
            if (i % 2 == 0) {
                nums[i] = ouList[ouIndex++];
            } else {
                nums[i] = jiList[jiIndex++];
            }
        }
        return nums;
    }
}
```

# 2169.得到0的操作数

```java
class Solution {
    public int countOperations(int num1, int num2) {
        int cnt = 0;
        while (num1 > 0 && num2 > 0) {
            if (num1 >= num2) {
                num1 = num1 - num2;
            } else {
                num2 = num2 - num1;
            }
            cnt++;
        }
        return cnt;
    }
}
```



# 2176.统计数组中相等且可以被整除的数对

```java
class Solution {
    public int countPairs(int[] nums, int k) {
        int result = 0;
        for (int i = 0; i < nums.length; i++) {
            for (int j = i + 1; j < nums.length; j++) {
                if (nums[i] == nums[j] && (i * j) % k == 0) {
                    result++;
                }
            }
        }
        return result;
    }
}
```

# 2180.统计各位数字之和为偶数的整数个数

```java
class Solution {
    public int countEven(int num) {
        int cnt = 0;
        for (int i = 1; i <= num; i++) {
            int temp = 0;
            int number = i;
            while (number > 0) {
                temp += number % 10;
                number /= 10;
            }
            if (temp % 2 == 0) {
                cnt++;
            }
        }
        return cnt;
    }
}
```



# 2181.合并零之间的节点

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeNodes(ListNode head) {
        ListNode left = head;
        ListNode right = head.next;
        int sum = 0;
        while (right != null) {
            sum += right.val;
            if (right.val == 0) {
                left.next.val = sum;
                left.next.next = right.next;
                left = left.next;
                sum = 0;
            }
            right = right.next;
        }
        return head.next;
    }
}
```

# 2185.统计包含给定前缀的字符串

```java
class Solution {
    public int prefixCount(String[] words, String pref) {
        int result = 0;
        for (int i = 0; i < words.length; i++) {
            if (words[i].indexOf(pref) == 0) {
                result++;
            }
        }
        return result;
    }
}
```



# 2190.数组中紧跟key之后出现最频繁的数字

```java
class Solution {
    public int mostFrequent(int[] nums, int key) {
        int[] cntList = new int[1001];
        for (int i = 0; i < nums.length - 1; i++) {
            if (nums[i] == key) {
                cntList[nums[i + 1]]++;
            }
        }
        int maxCnt = 0;
        int result = 0;
        for (int i = 0; i < cntList.length; i++) {
            if (cntList[i] > maxCnt) {
                maxCnt = cntList[i];
                result = i;
            }
        }
        return result;
    }
}
```

# 2194.Excel表中某个范围内的单元格

```java
class Solution {
    public List<String> cellsInRange(String s) {
        char letterLeft = s.charAt(0);
        char letterRight = s.charAt(3);
        int numberLeft = s.charAt(1) - '0';
        int numberRight = s.charAt(4) - '0';
        List<String> result = new ArrayList<>();
        for (int i = letterLeft; i <= letterRight; i++) {
            for (int j = numberLeft; j <= numberRight; j++) {
                String temp = (char) i + "" + j;
                result.add(temp);
            }
        }
        return result;
    }
}
```

# 2200.找出数组中的所有K近邻下标

```java
class Solution {
    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {
        List<Integer> resultList = new ArrayList<>();
        for (int i = 0; i < nums.length; i++) {
            for (int j = Math.max(0, i - k); j < Math.min(nums.length, i + k + 1); j++) {
                if (nums[j] == key) {
                    resultList.add(i);
                    break;
                }
            }
        }
        return resultList;
    }
}
```

