# 2103.环和杆

```java
class Solution {
    public int countPoints(String rings) {
        List<Set<Character>> resultList = new ArrayList<>();
        for (int i = 0; i < 10; i++) {
            resultList.add(new HashSet<>());
        }
        for (int i = 0; i < rings.length(); i+= 2) {
            char color = rings.charAt(i);
            int number = rings.charAt(i + 1) - '0';
            Set<Character> tempSet = resultList.get(number);
            tempSet.add(color);
        }
        int result = 0;
        for (int i = 0; i < 10; i++) {
            Set<Character> tempSet = resultList.get(i);
            if (tempSet.size() == 3) {
                result++;
            }
        }
        return result;
    }
}
```



# 2108.找出数组中的第一个回文字符串

```java
class Solution {
    public String firstPalindrome(String[] words) {
        for (int i = 0; i < words.length; i++) {
            StringBuilder sb = new StringBuilder();
            for (int j = words[i].length() - 1; j >= 0; j--) {
                sb.append(words[i].charAt(j));
            }
            if (words[i].equals(sb.toString())) {
                return words[i];
            }
        }
        return "";
    }
}
```

```java
class Solution {
    public String firstPalindrome(String[] words) {
        for (int i = 0; i < words.length; i++) {
            boolean isHv = true;
            int left = 0;
            int right = words[i].length() - 1;
            while (left < right) {
                if (words[i].charAt(left) != words[i].charAt(right)) {
                    isHv = false;
                    break;
                }
                left++;
                right--;
            }
            if (isHv) {
                return words[i];
            }
        }
        return "";
    }
}
```



# 2109.向字符串添加空格

```java
class Solution {
    public String addSpaces(String s, int[] spaces) {
        char[] ch = s.toCharArray();
        int index = 0;
        StringBuilder result = new StringBuilder();
        for (int i = 0; i < ch.length; i++) {
            if (index < spaces.length && i == spaces[index]) {
                result.append(" ");
                index++;
            }
            result.append(ch[i]);
        }
        return result.toString();
    }
}
```

# 2114.句子中的最多单词数

```java
class Solution {
    public int mostWordsFound(String[] sentences) {
        int max = 0;
        for (int i = 0; i < sentences.length; i++) {
            int temp = 0;
            for (int j = 0; j < sentences[i].length(); j++) {
                if (sentences[i].charAt(j) == ' ') {
                    temp++;
                }
            }
            max = Math.max(max, temp + 1);
        }
        return max;
    }
}
```

# 2119.反转两次的数字

```java
class Solution {
    public boolean isSameAfterReversals(int num) {
        if (num == 0) {
            return true;
        }
        while (num % 10 == 0) {
            return false;
        }
        return true;
    }
}
```

# 2129.将标题首字母大写

```java
class Solution {
    public String capitalizeTitle(String title) {
        StringBuilder result = new StringBuilder();
        for (String s : title.split(" ")) {
            if (!result.isEmpty()) {
                result.append(' ');
            }
            if (s.length() >= 3) {
                result.append(s.substring(0, 1).toUpperCase());
                result.append(s.substring(1).toLowerCase());
            } else {
                result.append(s.toLowerCase());
            }
        }
        return result.toString();
    }
}
```

# 2130.链表最大孪生和

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public int pairSum(ListNode head) {
        Deque<ListNode> queue = new LinkedList<>();
        int max = 0;
        while (head != null) {
            queue.add(head);
            head = head.next;
        }
        while (!queue.isEmpty()) {
            ListNode node1 = queue.pollFirst();
            ListNode node2 = queue.pollLast();
            max = Math.max(max, node1.val + node2.val);
        }
        return max;
    }
}
```

# 2133.检查是否每一行每一列都包含全部整数

```java
class Solution {
    public boolean checkValid(int[][] matrix) {
        List<Set<Integer>> lieList = new ArrayList<>();
        List<Set<Integer>> hangList = new ArrayList<>();
        for (int i = 0; i < matrix.length; i++) {
            lieList.add(new HashSet<>());
            hangList.add(new HashSet<>());
        }
        for (int i = 0; i < matrix.length; i++) {
            for (int j = 0; j < matrix[0].length; j++) {
                Set<Integer> lieSet = lieList.get(j);
                Set<Integer> hangSet = hangList.get(i);
                if (!lieSet.add(matrix[i][j]) || !hangSet.add(matrix[i][j])) {
                    return false;
                }
            }
        }
        return true;
    }
}
```



# 2144.打折购买糖果的最小开销

```java
class Solution {
    public int minimumCost(int[] cost) {
        Arrays.sort(cost);
        int indexX = cost.length - 1;
        int indexY = cost.length - 2;
        int result = 0;
        while (indexX >=0 && indexY >= 0) {
            result += cost[indexX]  + cost[indexY];
            indexX -= 3;
            indexY -= 3;
        }
        if (indexX >= 0) {
            result += cost[indexX];
        }
        if (indexY >= 0) {
            result += cost[indexY];
        }
        return result;
    }
}
```



# 2148.元素计数

```java
class Solution {
    public int countElements(int[] nums) {
        bubblSort(nums);
        int number = 0;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] > nums[0] && nums[i] < nums[nums.length - 1]) {
                number++;
            }
        }
        return number;
    }
    public void bubblSort(int[] nums) {
        int n = nums.length;
        for (int i = n - 1; i > 0; i--) {
            for (int j = 0; j < i; j++) {
                if (nums[j] > nums[i]) {
                    int temp = nums[j];
                    nums[j] = nums[i];
                    nums[i] = temp;
                }
            }
        }
    }
}
```

# 2154.将找到的值乘以2

```java
class Solution {
    public int findFinalValue(int[] nums, int original) {
        Set<Integer> resultSet = new HashSet<>();
        for (int i = 0; i < nums.length; i++) {
            resultSet.add(nums[i]);
        }
        while (resultSet.contains(original)) {
            original *= 2;
        }
        return original;
    }
}
```

# 2160.拆分数位后四位数字的最小和

```java
class Solution {
    public int minimumSum(int num) {
        int[] cntList = new int[10];
        while (num > 0) {
            int number = num % 10;
            num /= 10;
            cntList[number]++;
        }
        int cnt = 2;
        int sum = 0;
        for (int i = 0; i < cntList.length; i++) {
            if (cntList[i] > 0) {
                if (cnt >= cntList[i]) {
                    sum += i * 10 * cntList[i];
                    cnt -= cntList[i];
                } else {
                    sum += i * 10 * cnt + i * (cntList[i] - cnt);
                    cnt = 0;
                }
            }
        }
        return sum;
    }
}
```

# 2164.对奇偶下标分别排序

```java
class Solution {
    public int[] sortEvenOdd(int[] nums) {
        Integer[] jiList = new Integer[nums.length / 2];
        Integer[] ouList = new Integer[nums.length / 2 + nums.length % 2];
        int jiIndex = 0;
        int ouIndex = 0;
        for (int i = 0; i < nums.length; i++) {
            if (i % 2 == 0) {
                ouList[ouIndex++] = nums[i];
            } else {
                jiList[jiIndex++] = nums[i];
            }
        }
        Arrays.sort(jiList, Collections.reverseOrder());
        Arrays.sort(ouList);
        jiIndex = 0;
        ouIndex = 0;
        for (int i = 0; i < nums.length; i++) {
            if (i % 2 == 0) {
                nums[i] = ouList[ouIndex++];
            } else {
                nums[i] = jiList[jiIndex++];
            }
        }
        return nums;
    }
}
```



# 2181.合并零之间的节点

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeNodes(ListNode head) {
        ListNode left = head;
        ListNode right = head.next;
        int sum = 0;
        while (right != null) {
            sum += right.val;
            if (right.val == 0) {
                left.next.val = sum;
                left.next.next = right.next;
                left = left.next;
                sum = 0;
            }
            right = right.next;
        }
        return head.next;
    }
}
```

# 2190.数组中紧跟key之后出现最频繁的数字

```java
class Solution {
    public int mostFrequent(int[] nums, int key) {
        int[] cntList = new int[1001];
        for (int i = 0; i < nums.length - 1; i++) {
            if (nums[i] == key) {
                cntList[nums[i + 1]]++;
            }
        }
        int maxCnt = 0;
        int result = 0;
        for (int i = 0; i < cntList.length; i++) {
            if (cntList[i] > maxCnt) {
                maxCnt = cntList[i];
                result = i;
            }
        }
        return result;
    }
}
```

