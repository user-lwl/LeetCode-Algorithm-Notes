# 面试题 08.01.三步问题

```java
class Solution {
    public int waysToStep(int n) {
        if (n < 2) {
            return 1;
        } else if (n == 2) {
            return 2;
        }
        long[] result = new long[n + 1];
        result[0] = 1;
        result[1] = 1;
        result[2] = 2;
        for (int i = 3; i <= n; i++) {
            result[i] = (result[i - 1] + result[i - 2] + result[i - 3]) % 1000000007;
        }
        return (int) result[n];
    }
}
```

# 面试题 08.02.迷路的机器人

```java
class Solution {

    int[][] path;

    boolean[][] visited;

    int xmax;

    int ymax;

    List<List<Integer>> result;

    public List<List<Integer>> pathWithObstacles(int[][] obstacleGrid) {
        path = obstacleGrid;
        xmax = obstacleGrid.length;
        ymax = obstacleGrid[0].length;
        visited = new boolean[xmax][ymax];
        result = new ArrayList<>();
        if (obstacleGrid[0][0] == 1 || obstacleGrid[xmax - 1][ymax - 1] == 1) {
            return result;
        }
        getPath(0, 0);
        return result;
    }

    public boolean getPath(int x, int y) {
        if (x >= xmax || y >= ymax || path[x][y] == 1 || visited[x][y]) {
            return false;
        }
        List<Integer> dot = new ArrayList<>();
        dot.add(x);
        dot.add(y);
        result.add(dot);
        visited[x][y] = true;
        if (x == xmax - 1 && y == ymax - 1) {
            return true;
        }
        if (getPath(x + 1, y) || getPath(x, y + 1)) {
            return true;
        }
        result.remove(result.size() - 1);
        return false;
    }
}
```

# 面试题 08.03.魔术索引

```java
class Solution {
    public int findMagicIndex(int[] nums) {
        for (int i = 0; i < nums.length; i++) {
            if (i == nums[i]) {
                return i;
            }
        }
        return -1;
    }
}
```



# 面试题 08.05.递归乘法

```java
class Solution {
    public int multiply(int A, int B) {
        return A*B;
    }
}
```

# 面试题 08.09.括号

```java
class Solution {

    int maxN;

    public List<String> generateParenthesis(int n) {
        maxN = n;
        return getPath(0, n, n, "");
    }

    public List<String> getPath(int leftNumber, int left, int right, String result) {
        List<String> resList = new ArrayList<>();
        if (left == 0 && right == 0) {
            resList.add(result);
            return resList;
        }
        List<String> pathListLeft = new ArrayList<>();
        List<String> pathListRight = new ArrayList<>();
        if (left > 0) {
            pathListLeft = getPath(leftNumber + 1, left - 1, right, result + "(");
        }
        if (leftNumber > 0 && right > 0) {
            pathListRight = getPath(leftNumber - 1, left, right - 1, result + ")");
        }
        resList.addAll(pathListLeft);
        resList.addAll(pathListRight);
        return resList;
    }
}
```

# 面试题 08.10.颜色填充

```java
class Solution {

    int[][] globalImage;

    int[][] visited;

    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {
        globalImage = image;
        visited = new int[image.length][image[0].length];
        getColor(sr, sc, newColor);
        return globalImage;
    }

    public void getColor(int sr, int sc, int newColor) {
        int srcColor = globalImage[sr][sc];
        globalImage[sr][sc] = newColor;
        visited[sr][sc] = 1;
        if (sr > 0 && globalImage[sr - 1][sc] == srcColor && visited[sr - 1][sc] == 0) {
            getColor(sr - 1, sc, newColor);
        }
        if (sc > 0 && globalImage[sr][sc - 1] == srcColor && visited[sr][sc - 1] == 0) {
            getColor(sr, sc - 1, newColor);
        }
        if (sr < globalImage.length - 1 && globalImage[sr + 1][sc] == srcColor && visited[sr + 1][sc] == 0) {
            getColor(sr + 1, sc, newColor);
        }
        if (sc < globalImage[0].length - 1 && globalImage[sr][sc + 1] == srcColor && visited[sr][sc + 1] == 0) {
            getColor(sr, sc + 1, newColor);
        }
    }
}
```



# 面试题 08.11.硬币

```java
class Solution {
    public int waysToChange(int n) {
        int[] b = {1, 5, 10, 25};
        int[] dp = new int[n + 1];
        dp[0] = 1;
        for (int i = 0; i < 4; i++) {
            for (int j = b[i]; j <= n; j++) {
                dp[j] = (dp[j] + dp[j - b[i]]) % 1000000007;
            }
        }
        return dp[n];
    }
}
```

### 