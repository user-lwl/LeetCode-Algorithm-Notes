# 3206.交替组Ⅰ

```java
class Solution {
    public int numberOfAlternatingGroups(int[] colors) {
        int[] tempColors = new int[colors.length + 2];
        System.arraycopy(colors, 0, tempColors, 0, colors.length);
        tempColors[tempColors.length - 2] = colors[0];
        tempColors[tempColors.length - 1] = colors[1];
        int left = 0;
        int mid = 1;
        int right = 2;
        int result = 0;
        while (right < tempColors.length) {
            if (tempColors[left] != tempColors[mid] && tempColors[mid] != tempColors[right]) {
                result++;
            }
            left++;
            mid++;
            right++;
        }
        return result;
    }
}
```

# 3210.找出加密后的字符串

```java
class Solution {
    public String getEncryptedString(String s, int k) {
        k = k % s.length();
        return s.substring(k) + s.substring(0, k);
    }
}
```



# 3216.交换后字典序最小的字符串

```java
class Solution {
    public String getSmallestString(String s) {
        char[] sChar = s.toCharArray();
        for (int i = 0; i < sChar.length - 1; i++) {
            if (sChar[i] > sChar[i + 1] && sChar[i] % 2 == sChar[i + 1] % 2) {
                char temp = sChar[i];
                sChar[i] = sChar[i + 1];
                sChar[i + 1] = temp;
                break;
            }
        }
        return new String(sChar);
    }
}
```

# 3226.使两个整数相等的位更改次数

```java
class Solution {
    public int minChanges(int n, int k) {
        int cnt = 0;
        for (int i = 31; i >= 0; i--) {
            int bitN = (n >> i) & 1;
            int bitK = (k >> i) & 1;
            if (bitK == bitN) {
                continue;
            } else if (bitN == 1) {
                cnt++;
            } else {
                return -1;
            }
        }
        return cnt;
    }
}
```

# 3232.判断是否可以赢得数字游戏

```java
class Solution {
    public boolean canAliceWin(int[] nums) {
        int ge = 0;
        int shi = 0;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] < 10) {
                ge += nums[i];
            } else {
                shi += nums[i];
            }
        }
        return ge != shi;
    }
}
```



# 3238.求出胜利玩家的数目

```java
class Solution {
    public int winningPlayerCount(int n, int[][] pick) {
        int[][] result = new int[n][11];
        for (int i = 0; i < pick.length; i++) {
            result[pick[i][0]][pick[i][1]]++;
        }
        int cnt = 0;
        for (int i = 0; i < result.length; i++) {
            for (int j = 0; j < result[0].length; j++) {
                if (result[i][j] > i) {
                    cnt++;
                    break;
                }
            }
        }
        return cnt;
    }
}
```

# 3242.设计相邻元素求和服务

```java
class NeighborSum {

    int[][] result;

    public NeighborSum(int[][] grid) {
        result = new int[grid.length + 2][grid[0].length + 2];
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[0].length; j++) {
                result[i + 1][j + 1] = grid[i][j];
            }
        }
    }
    
    public int adjacentSum(int value) {
        int x = -1;
        int y = -1;
        for (int i = 1; i < result.length - 1; i++) {
            for (int j = 1; j < result[0].length - 1; j++) {
                if (result[i][j] == value) {
                    x = i;
                    y = j;
                    break;
                }
            }
            if (x != -1) {
                break;
            }
        }
        return result[x - 1][y] + result[x + 1][y] + result[x][y - 1] + result[x][y + 1];
    }
    
    public int diagonalSum(int value) {
        int x = -1;
        int y = -1;
        for (int i = 1; i < result.length - 1; i++) {
            for (int j = 1; j < result[0].length - 1; j++) {
                if (result[i][j] == value) {
                    x = i;
                    y = j;
                    break;
                }
            }
            if (x != -1) {
                break;
            }
        }
        return result[x - 1][y - 1] + result[x + 1][y + 1] + result[x + 1][y - 1] + result[x - 1][y + 1];
    }
}

/**
 * Your NeighborSum object will be instantiated and called as such:
 * NeighborSum obj = new NeighborSum(grid);
 * int param_1 = obj.adjacentSum(value);
 * int param_2 = obj.diagonalSum(value);
 */
```

# 3248.矩阵中的蛇

```java
class Solution {
    public int finalPositionOfSnake(int n, List<String> commands) {
        int i = 0;
        int j = 0;
        for (int index = 0; index < commands.size(); index++) {
            String pass = commands.get(index);
            if ("UP".equals(pass)) {
                i--;
            } else if ("DOWN".equals(pass)) {
                i++;
            } else if ("RIGHT".equals(pass)) {
                j++;
            } else {
                j--;
            }
        }
        return (i * n) + j;
    }
}
```



# 3258.统计满足K约束的子字符串数量Ⅰ

```java
class Solution {
    public int countKConstraintSubstrings(String s, int k) {
        char[] sChar = s.toCharArray();
        int result = 0;
        for (int i = 0; i < sChar.length; i++) {
            int zeroCnt = 0;
            int oneCnt = 0;
            for (int j = i; j < sChar.length; j++) {
                int temp = sChar[j] - '0';
                if (temp == 0) {
                    zeroCnt++;
                } else {
                    oneCnt++;
                }
                if (zeroCnt > k && oneCnt > k) {
                    break;
                } else {
                    result++;
                }
            } 
        }
        return result;
    }
}
```

# 3264.K次乘运算后的最终数组Ⅰ

```java
class Solution {
    public int[] getFinalState(int[] nums, int k, int multiplier) {
        while (k > 0) {
            int index = 0;
            int minNumber = 9999;
            for (int i = 0; i < nums.length; i++) {
                if (nums[i] < minNumber) {
                    minNumber = nums[i];
                    index = i;
                }
            }
            nums[index] = nums[index] * multiplier;
            k--;
        }
        return nums;
    }
}
```



# 3274.检查棋盘方格颜色是否相同

```java
class Solution {
    public boolean checkTwoChessboards(String coordinate1, String coordinate2) {
        return getColor(coordinate1) == getColor(coordinate2);
    }
    // 0-黑色 1-白色
    public int getColor(String card) {
        int xIndex = card.charAt(0) - 'a';
        int yIndex = card.charAt(1) - '1';
        if ((xIndex + yIndex) % 2 == 0) {
            return 0;
        }
        return 1;
    }
}
```

# 3280.将日期转换为二进制表示

```java
class Solution {
    public String convertDateToBinary(String date) {
        String[] dateString = date.split("-");
        int year = Integer.valueOf(dateString[0]);
        int month = Integer.valueOf(dateString[1]);
        int day = Integer.valueOf(dateString[2]);
        return numberToBinary(year) + "-" + numberToBinary(month) + "-" + numberToBinary(day);
    }
    public String numberToBinary(int number) {
        StringBuilder sb = new StringBuilder();
        while (number > 0) {
            sb.append(number & 1);
            number = number >> 1;
        }
        return sb.reverse().toString();
    }
}
```

# 3285.找到稳定山的下标

```java
class Solution {
    public List<Integer> stableMountains(int[] height, int threshold) {
        List<Integer> result = new ArrayList<>();
        for (int i = 1; i < height.length; i++) {
            if (height[i - 1] > threshold) {
                result.add(i);
            }
        }
        return result;
    }
}
```

# 3289.数字小镇中的捣蛋鬼

```java
class Solution {
    public int[] getSneakyNumbers(int[] nums) {
        int[] result = new int[2];
        int index = 0;
        int[] temp = new int[nums.length - 2];
        for (int i = 0; i < nums.length; i++) {
            temp[nums[i]]++;
            if (temp[nums[i]] == 2) {
                result[index++] = nums[i];
                if (index == 2) {
                    return result;
                }
            }
        }
        return result;
    }
}
```

# 3300.替换为数位和以后的最小元素

```java
class Solution {
    public int minElement(int[] nums) {
        int result = 99999;
        for (int i = 0; i < nums.length; i++) {
            int temp = nums[i];
            int number = 0;
            while (temp > 0) {
                number += temp % 10;
                temp /= 10;
            }
            result = Math.min(result, number);
        }
        return result;
    }
}
```

