# 3206.交替组Ⅰ

```java
class Solution {
    public int numberOfAlternatingGroups(int[] colors) {
        int[] tempColors = new int[colors.length + 2];
        System.arraycopy(colors, 0, tempColors, 0, colors.length);
        tempColors[tempColors.length - 2] = colors[0];
        tempColors[tempColors.length - 1] = colors[1];
        int left = 0;
        int mid = 1;
        int right = 2;
        int result = 0;
        while (right < tempColors.length) {
            if (tempColors[left] != tempColors[mid] && tempColors[mid] != tempColors[right]) {
                result++;
            }
            left++;
            mid++;
            right++;
        }
        return result;
    }
}
```



# 3216.交换后字典序最小的字符串

```java
class Solution {
    public String getSmallestString(String s) {
        char[] sChar = s.toCharArray();
        for (int i = 0; i < sChar.length - 1; i++) {
            if (sChar[i] > sChar[i + 1] && sChar[i] % 2 == sChar[i + 1] % 2) {
                char temp = sChar[i];
                sChar[i] = sChar[i + 1];
                sChar[i + 1] = temp;
                break;
            }
        }
        return new String(sChar);
    }
}
```

# 3226.使两个整数相等的位更改次数

```java
class Solution {
    public int minChanges(int n, int k) {
        int cnt = 0;
        for (int i = 31; i >= 0; i--) {
            int bitN = (n >> i) & 1;
            int bitK = (k >> i) & 1;
            if (bitK == bitN) {
                continue;
            } else if (bitN == 1) {
                cnt++;
            } else {
                return -1;
            }
        }
        return cnt;
    }
}
```



# 3238.求出胜利玩家的数目

```java
class Solution {
    public int winningPlayerCount(int n, int[][] pick) {
        int[][] result = new int[n][11];
        for (int i = 0; i < pick.length; i++) {
            result[pick[i][0]][pick[i][1]]++;
        }
        int cnt = 0;
        for (int i = 0; i < result.length; i++) {
            for (int j = 0; j < result[0].length; j++) {
                if (result[i][j] > i) {
                    cnt++;
                    break;
                }
            }
        }
        return cnt;
    }
}
```

# 3242.设计相邻元素求和服务

```java
class NeighborSum {

    int[][] result;

    public NeighborSum(int[][] grid) {
        result = new int[grid.length + 2][grid[0].length + 2];
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[0].length; j++) {
                result[i + 1][j + 1] = grid[i][j];
            }
        }
    }
    
    public int adjacentSum(int value) {
        int x = -1;
        int y = -1;
        for (int i = 1; i < result.length - 1; i++) {
            for (int j = 1; j < result[0].length - 1; j++) {
                if (result[i][j] == value) {
                    x = i;
                    y = j;
                    break;
                }
            }
            if (x != -1) {
                break;
            }
        }
        return result[x - 1][y] + result[x + 1][y] + result[x][y - 1] + result[x][y + 1];
    }
    
    public int diagonalSum(int value) {
        int x = -1;
        int y = -1;
        for (int i = 1; i < result.length - 1; i++) {
            for (int j = 1; j < result[0].length - 1; j++) {
                if (result[i][j] == value) {
                    x = i;
                    y = j;
                    break;
                }
            }
            if (x != -1) {
                break;
            }
        }
        return result[x - 1][y - 1] + result[x + 1][y + 1] + result[x + 1][y - 1] + result[x - 1][y + 1];
    }
}

/**
 * Your NeighborSum object will be instantiated and called as such:
 * NeighborSum obj = new NeighborSum(grid);
 * int param_1 = obj.adjacentSum(value);
 * int param_2 = obj.diagonalSum(value);
 */
```

# 3258.统计满足K约束的子字符串数量Ⅰ

```java
class Solution {
    public int countKConstraintSubstrings(String s, int k) {
        char[] sChar = s.toCharArray();
        int result = 0;
        for (int i = 0; i < sChar.length; i++) {
            int zeroCnt = 0;
            int oneCnt = 0;
            for (int j = i; j < sChar.length; j++) {
                int temp = sChar[j] - '0';
                if (temp == 0) {
                    zeroCnt++;
                } else {
                    oneCnt++;
                }
                if (zeroCnt > k && oneCnt > k) {
                    break;
                } else {
                    result++;
                }
            } 
        }
        return result;
    }
}
```

