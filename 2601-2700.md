# 2605.从两个数字数组里生成最小数字

```java
class Solution {
    public int minNumber(int[] nums1, int[] nums2) {
        int nums1Min = 10;
        int nums2Min = 10;
        Set<Integer> tempSet = new HashSet<>();
        for (int i = 0; i < nums1.length; i++) {
            nums1Min = Math.min(nums1Min, nums1[i]);
            tempSet.add(nums1[i]);
        }
        int minCommon = 10;
        for (int i = 0; i < nums2.length; i++) {
            nums2Min = Math.min(nums2Min, nums2[i]);
            if (tempSet.contains(nums2[i])) {
                minCommon = Math.min(minCommon, nums2[i]);
            }
        }
        if (minCommon != 10) {
            return minCommon;
        }
        return Math.min(nums1Min, nums2Min) * 10 + Math.max(nums1Min, nums2Min);
    }
}
```

# 2609.最长平衡子字符串

```java
class Solution {
    public int findTheLongestBalancedSubstring(String s) {
        int result = 0;
        for (int i = 0; i < s.length(); i++) {
            int zeroCnt = 0;
            int oneCnt = 0;
            for (int j = i; j < s.length(); j++) {
                char temp = s.charAt(j);
                if (temp == '0' && oneCnt == 0) {
                    zeroCnt++;
                } else if (temp == '0' && oneCnt != 0) {
                    break;
                } else if (temp == '1' && oneCnt >= zeroCnt) {
                    break;
                } else if (temp == '1' && oneCnt < zeroCnt) {
                    oneCnt++;
                    if (oneCnt == zeroCnt) {
                        result = Math.max(result, zeroCnt + oneCnt);
                    }
                }
            }
        }
        return result;
    }
}
```



# 2614.对角线上的质数

```java
class Solution {
    public int diagonalPrime(int[][] nums) {
        int result = 0;
        for (int i = 0; i < nums.length; i++) {
            int number1 = nums[i][i];
            int number2 = nums[i][nums.length - 1 - i];
            if (isZ(number1)) {
                result = Math.max(result, number1);
            }
            if (isZ(number2)) {
                result = Math.max(result, number2);
            }
        }
        return result;
    }
    public boolean isZ(int number) {
        if (number <= 1) {
            return false;
        }
        for (int i = 2; i <= Math.sqrt(number); i++) {
            if (number % i == 0) {
                return false;
            }
        }
        return true;
    }
}
```

# 2639.查询网格图中每一列的宽度

```java
class Solution {
    public int[] findColumnWidth(int[][] grid) {
        int[] maxLen = new int[grid[0].length];
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[0].length; j++) {
                int len = String.valueOf(grid[i][j]).length();
                maxLen[j] = Math.max(maxLen[j], len);
            }
        }
        return maxLen;
    }
}
```

# 2643.一最多的行

```java
class Solution {
    public int[] rowAndMaximumOnes(int[][] mat) {
        int[] result = new int[2];
        for (int i = 0; i < mat.length; i++) {
            int cnt = 0;
            for (int j = 0; j < mat[0].length; j++) {
                if (mat[i][j] == 1) {
                    cnt++;
                }
            }
            if (cnt > result[1]) {
                result[0] = i;
                result[1] = cnt;
            }
        }
        return result;
    }
}
```

# 2644.找出可整除性得分最大的整数

```java
class Solution {
    public int maxDivScore(int[] nums, int[] divisors) {
        int result = -1;
        int score = -1;
        for (int i = 0; i < divisors.length; i++) {
            int temp = divisors[i];
            int tempScore = 0;
            for (int j = 0; j < nums.length; j++) {
                if (nums[j] % temp == 0) {
                    tempScore++;
                }
            }
            if (tempScore > score) {
                score = tempScore;
                result = temp;
            } else if (tempScore == score) {
                result = Math.min(result, temp);
            }
        }
        return result;
    }
}
```



# 2656. K个元素的最大和

```java
class Solution {
    public int maximizeSum(int[] nums, int k) {
        int max = 0;
        for (int i = 0; i < nums.length; i++) {
            max = Math.max(max, nums[i]);
        }
        return max * k + (k - 1) * k / 2;
    }
}
```

# 2678.老人的数目

```java
class Solution {
    public int countSeniors(String[] details) {
        int result = 0;
        for (int i = 0; i < details.length; i++) {
            int old = Integer.valueOf(details[i].substring(11, 13));
            if (old > 60) {
                result++;
            }
        }
        return result;
    }
}
```



# 2696.删除子串后的字符串最小长度

```java
class Solution {
    public int minLength(String s) {
        List<Character> tempChar = s.chars().mapToObj(c -> (char) c).collect(Collectors.toList());
        for (int i = 0; i < tempChar.size() - 1; i++) {
            if ((tempChar.get(i) == 'A' && tempChar.get(i + 1) == 'B') || (tempChar.get(i) == 'C' && tempChar.get(i + 1) == 'D')) {
                tempChar.remove(i);
                tempChar.remove(i);
                i -= 2;
                if (i < 0) {
                    i = -1;
                }
            }
        }
        return tempChar.size();
    }
}
```

# 2697.字典序最小回文串

```java
class Solution {
    public String makeSmallestPalindrome(String s) {
        char[] sChar = s.toCharArray();
        int left = 0;
        int right = sChar.length - 1;
        while (left < right) {
            sChar[left] = (char) Math.min(sChar[left], sChar[right]);
            sChar[right] = (char) Math.min(sChar[left], sChar[right]);
            right--;
            left++;
        }
        return new String(sChar);
    }
}
```

