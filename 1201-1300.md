# 1207.独一无二的出现次数

```java
class Solution {
    public boolean uniqueOccurrences(int[] arr) {
        Map<Integer, Integer> map = new HashMap<>();
        for (int num : arr) {
            map.put(num, map.getOrDefault(num, 0) + 1);
        }
        Set<Integer> set = new HashSet<>();
        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {
            if (!set.add(entry.getValue())) {
                return false;
            }
        }
        return true;
    }
}
```

# 1211.查询结果的质量和占比

```sql
# Write your MySQL query statement below
select query_name, round(avg(rating / position), 2) quality, round((count(case when rating < 3 then 1 end) * 100) / count(*), 2) poor_query_percentage from Queries group by query_name;
```

# 1217.玩筹码

```java
class Solution {
    public int minCostToMoveChips(int[] position) {
        int ji = 0;
        int ou = 0;
        for (int i = 0; i < position.length; i++) {
            if (position[i] % 2 == 0) {
                ou++;
            } else {
                ji++;
            }
        }
        return Math.min(ou, ji);
    }
}
```



# 1221.分割平衡字符串

```java
class Solution {
    public int balancedStringSplit(String s) {
        int result = 0;
        int temp = 0;
        char[] c = s.toCharArray();
        for (int i = 0; i < c.length; i++) {
            if (c[i] == 'R') {
                temp++;
            } else {
                temp--;
            }
            if (temp == 0) {
                result++;
            }
        }
        return result;
    }
}
```

# 1251.平均售价

```sql
# Write your MySQL query statement below
select a.product_id, ifnull(round(sum(a.price * b.units) / sum(b.units), 2), 0) average_price from Prices a left join UnitsSold b on a.product_id = b.product_id and b.purchase_date between a.start_date and a.end_date group by product_id;
```



# 1252.奇数值单元格的数目

```java
class Solution {
    public int oddCells(int m, int n, int[][] indices) {
        int[][] magix = new int[m][n];
        for (int i = 0; i < indices.length; i++) {
            for (int j = 0; j < m; j++) {
                magix[j][indices[i][1]]++;
            }
            for (int j = 0; j < n; j++) {
                magix[indices[i][0]][j]++;
            }
        }
        int result = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (magix[i][j] % 2 == 1) {
                    result++;
                }
            }
        }
        return result;
    }
}
```

# 1260.二维网格迁移

```java
class Solution {
    public List<List<Integer>> shiftGrid(int[][] grid, int k) {
        int m = grid.length;
        int n = grid[0].length;
        List<List<Integer>> res = new ArrayList<>();
        for (int i = 0; i < m; i++) {
            List<Integer> row = new ArrayList<>();
            for (int j = 0; j < n; j++) {
                row.add(0);
            }
            res.add(row);
        }
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                int index = (i * n + j + k) % (m * n);
                res.get(index / n).set(index % n, grid[i][j]);
            }
        }
        return res;
    }
}
```

# 1261.在受污染的二叉树中查找元素

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class FindElements {
    private Set<Integer> valSet;

    public FindElements(TreeNode root) {
        valSet = new HashSet<>();
        dfs(root, 0);
    }
    
    public boolean find(int target) {
        return valSet.contains(target);
    }

    public void dfs (TreeNode node, Integer val) {
        if (node == null) {
            return;
        }
        valSet.add(val);
        node.val = val;
        dfs(node.left, val * 2 + 1);
        dfs(node.right, val * 2 + 2);
    }
}

/**
 * Your FindElements object will be instantiated and called as such:
 * FindElements obj = new FindElements(root);
 * boolean param_1 = obj.find(target);
 */
```

# 1262.可被三整除的最大和

```java
class Solution {
    public int maxSumDivThree(int[] nums) {
        int len = nums.length;
        int[][] dp = new int[40001][3];
        for (int[] row : dp) {
            Arrays.fill(row, -1);
        }
        dp[0][0] = 0;
        dp[0][nums[0] % 3] = nums[0];
        for (int i = 1; i < len; i++) {
            for (int j = 0; j < 3; j++) {
                dp[i][j] = dp[i - 1][j];
                int pre = ((j - nums[i] % 3) + 3) % 3;
                if (dp[i - 1][pre] != -1) {
                    dp[i][j] = Math.max(dp[i][j], dp[i - 1][pre] + nums[i]);
                }
            }
        }
        return dp[len - 1][0];
    }
}
```

# 1275.找出井字棋的获胜者

```java
class Solution {

    int[][] jing = new int[3][3];

    public String tictactoe(int[][] moves) {
        for (int i = 0; i < moves.length; i++) {
            jing[moves[i][0]][moves[i][1]] = i % 2 == 0 ? -1 : 1;
            String result = isWin();
            if (!"".equals(result)) {
                return result;
            }
        }
        return moves.length == 9 ? "Draw" : "Pending";
    }

    public String isWin() {
        int line1 = jing[0][0] + jing[0][1] + jing[0][2];
        int line2 = jing[1][0] + jing[1][1] + jing[1][2];
        int line3 = jing[2][0] + jing[2][1] + jing[2][2];
        int lie1 = jing[0][0] + jing[1][0] + jing[2][0];
        int lie2 = jing[0][1] + jing[1][1] + jing[2][1];
        int lie3 = jing[0][2] + jing[1][2] + jing[2][2];
        int xie1 = jing[0][0] + jing[1][1] + jing[2][2];
        int xie2 = jing[0][2] + jing[1][1] + jing[2][0];
        if (line1 == 3 || line2 == 3 || line3 == 3 || lie1 == 3 || lie2 == 3 || lie3 == 3 || xie1 == 3 || xie2 == 3) {
            return "B";
        }
        if (line1 == -3 || line2 == -3 || line3 == -3 || lie1 == -3 || lie2 == -3 || lie3 == -3 || xie1 == -3 || xie2 == -3) {
            return "A";
        }
        return "";
    }
}
```

# 1280.学生们参加各科测试的次数

```sql
# Write your MySQL query statement below
select a.student_id, a.student_name, a.subject_name, ifnull(c.cnt, 0) attended_exams from 
(select * from Students d, Subjects b) a
left join
(select student_id, subject_name, count(*) cnt from Examinations group by student_id, subject_name) c
on a.student_id = c.student_id and a.subject_name = c.subject_name group by a.student_id, a.student_name, a.subject_name order by a.student_id, a.student_name, a.subject_name;
```



# 1290.二进制链表转整数

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public int getDecimalValue(ListNode head) {
        int sum = 0;
        while (head != null) {
            sum = sum * 2 + head.val;
            head = head.next;
        }
        return sum;
    }
}
```

### 