# 3701.计算交替和

```java
class Solution {
    public int alternatingSum(int[] nums) {
        int result = 0;
        for (int i = 0; i < nums.length; i++) {
            result += nums[i] * Math.pow(-1, i);
        }
        return result;
    }
}
```

# 3702.按位异或非零的最长子序列

```java
class Solution {
    public int longestSubsequence(int[] nums) {
        Arrays.sort(nums);
        if (nums[nums.length - 1] == 0) {
            return 0;
        }
        int result = nums[0];
        int len = nums.length;
        int index = nums.length - 1;
        for (int i = 1; i < nums.length; i++) {
            result ^= nums[i];
        }
        while (result == 0) {
            result ^= nums[index--];
            len--;
        }
        return len;
    }
}
```

# 3707.相等子字符串分数

```java
class Solution {
    public boolean scoreBalance(String s) {
        int[] score = new int[s.length()];
        int sum = 0;
        for (int i = 0; i < s.length(); i++) {
            score[i] = s.charAt(i) - 'a' + 1;
            sum += score[i];
        }
        int index = 0;
        int left = 0;
        int right = sum;
        while (left < right) {
            left += score[index];
            right -= score[index];
            index++;
            if (left == right) {
                return true;
            }
        }
        return false;
    }
}
```

# 3708.最长斐波那契子数组

```java
class Solution {
    public int longestSubarray(int[] nums) {
        int maxLen = 2;
        for (int i = 2; i < nums.length; i++) {
            if (nums[i] == nums[i - 1] + nums[i - 2]) {
                int startIndex = i - 2;
                while (i < nums.length && nums[i] == nums[i - 1] + nums[i - 2]) {
                    i++;
                }
                maxLen = Math.max(maxLen, i - startIndex);
                i--;
            }
        }
        return maxLen;
    }
}
```

# 3712.出现次数能被K整除的元素总和

```java
class Solution {
    public int sumDivisibleByK(int[] nums, int k) {
        int[] cntList = new int[101];
        for (int i = 0; i < nums.length; i++) {
            cntList[nums[i]]++;
        }
        int result = 0;
        for (int i = 0; i < cntList.length; i++) {
            if (cntList[i] % k == 0) {
                result += i * cntList[i];
            }
        }
        return result;
    }
}
```

# 3713.最长的平衡子串Ⅰ

```java
class Solution {
    public int longestBalanced(String s) {
        int result = 0;
        for (int i = 0; i < s.length(); i++) {
            int[] tempList = new int[26];
            int tempIndex = s.charAt(i) - 'a';
            for (int j = i; j < s.length(); j++) {
                int index = s.charAt(j) - 'a';
                tempList[index]++;
                boolean isT = true;
                for (int k = 0; k < tempList.length; k++) {
                    if (tempList[k] != 0 && tempList[k] != tempList[tempIndex]) {
                        isT = false;
                    }
                }
                if (isT) {
                    result = Math.max(result, j - i + 1);
                }
            }
        }
        return result;
    }
}
```

# 3718.缺失的最小倍数

```java
class Solution {
    public int missingMultiple(int[] nums, int k) {
        Set<Integer> tempSet = new HashSet<>();
        for (int i = 0; i < nums.length; i++) {
            tempSet.add(nums[i]);
        }
        int target = 1;
        while (target > 0) {
            int temp = target * k;
            if (!tempSet.contains(temp)) {
                return temp;
            }
            target++;
        }
        return -1;
    }
}
```

# 3719.最长平衡子数组Ⅰ

```java
class Solution {
    public int longestBalanced(int[] nums) {
        int result = 0;
        for (int i = 0; i < nums.length; i++) {
            Set<Integer> jiSet = new HashSet<>();
            Set<Integer> ouSet = new HashSet<>();
            for (int j = i; j < nums.length; j++) {
                int temp = nums[j];
                if (temp % 2 == 0) {
                    ouSet.add(temp);
                } else {
                    jiSet.add(temp);
                }
                if (jiSet.size() == ouSet.size()) {
                    result = Math.max(result, j - i + 1);
                }
            }
        }
        return result;
    }
}
```

