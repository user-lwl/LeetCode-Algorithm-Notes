# 3005.最大频率元素计数

```java
class Solution {
    public int maxFrequencyElements(int[] nums) {
        int[] cntList = new int[101];
        for (int i = 0; i < nums.length; i++) {
            cntList[nums[i]]++;
        }
        Arrays.sort(cntList);
        int result = cntList[cntList.length - 1];
        for (int i = cntList.length - 2; i >= 0; i--) {
            if (cntList[i] == cntList[i + 1]) {
                result += cntList[i];
            } else {
                break;
            }
        }
        return result;
    }
}
```



# 3010.将数组分成最小总代价的子数组Ⅰ

```java
class Solution {
    public int minimumCost(int[] nums) {
        int first = nums[0];
        Arrays.sort(nums);
        int sum = 0;
        for (int i = 0; i < 2; i++) {
            sum += nums[i];
        }
        if (nums[1] >= first) {
            sum += nums[2];
        } else {
            sum += first;
        }
        return sum;
    }
}
```

# 3014.输入单词需要的最少按键次数Ⅰ

```java
class Solution {
    public int minimumPushes(String word) {
        int len = word.length();
        int result = 0;
        result += Math.min(8, len);
        len -= 8;
        if (len > 0) {
            result += Math.min(8, len) * 2;
            len -= 8;
        }
        if (len > 0) {
            result += Math.min(8, len) * 3;
            len -= 8;
        }
        if (len > 0) {
            result += len * 4;
        }
        return result;
    }
}
```

# 3019.按键变更的次数

```java
class Solution {
    public int countKeyChanges(String s) {
        int result = 0;
        for (int i = 1; i < s.length(); i++) {
            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(i - 1))) {
                result++;
            }
        }
        return result;
    }
}
```



# 3024.三角形类型

```java
class Solution {
    public String triangleType(int[] nums) {
        Arrays.sort(nums);
        int line1 = nums[0];
        int line2 = nums[1];
        int line3 = nums[2];
        if (line1 + line2 > line3) {
            if (line1 == line2 || line2 == line3 || line1 == line3) {
                if (line1 == line2 && line2 == line3) {
                    return "equilateral";
                } else {
                    return "isosceles";
                }
            } else {
                return "scalene";
            }
        }
        return "none";
    }
}
```

# 3033.修改矩阵

```java
class Solution {
    public int[][] modifiedMatrix(int[][] matrix) {
        int[] maxLie = new int[matrix[0].length];
        for (int i = 0; i < matrix.length; i++) {
            for (int j = 0; j < matrix[0].length; j++) {
                maxLie[j] = Math.max(maxLie[j], matrix[i][j]);
            }
        }
        for (int i = 0; i < matrix.length; i++) {
            for (int j = 0; j < matrix[0].length; j++) {
                if (matrix[i][j] == -1) {
                    matrix[i][j] = maxLie[j];
                }
            }
        }
        return matrix;
    }
}
```

# 3042.统计前后缀下标对Ⅰ

```java
class Solution {
    public int countPrefixSuffixPairs(String[] words) {
        int result = 0;
        for (int i = 0; i < words.length; i++) {
            for (int j = i + 1; j < words.length; j++) {
                if (isPrefixAndSuffix(words[j], words[i])) {
                    result++;
                }
            }
        }
        return result;
    }

    public boolean isPrefixAndSuffix(String str1, String str2) {
        if (str1.length() < str2.length()) {
            return false;
        }
        return str1.indexOf(str2) == 0 && str2.equals(str1.substring(str1.length() - str2.length()));
    }
}
```



# 3046.分割数组

```java
class Solution {
    public boolean isPossibleToSplit(int[] nums) {
        int[] cnt = new int[101];
        for (int i = 0; i < nums.length; i++) {
            cnt[nums[i]]++;
        }
        for (int i = 0; i < cnt.length; i++) {
            if (cnt[i] > 2) {
                return false;
            }
        }
        return true;
    }
}
```



# 3074.重新分装苹果

```java
class Solution {
    public int minimumBoxes(int[] apple, int[] capacity) {
        int sum = 0;
        for (int i = 0; i < apple.length; i++) {
            sum += apple[i];
        }
        Integer[] Integernum = Arrays.stream(capacity).boxed().toArray(Integer[]::new);
        Arrays.sort(Integernum, new Comparator<Integer>() {
            public int compare(Integer o1, Integer o2) {
                return o2 - o1;
            }
        });
        for (int i = 0; i < Integernum.length; i++) {
            sum -= Integernum[i];
            if (sum <= 0) {
                return i + 1;
            }
        }
        return -1;
    }
}
```

# 3083.字符串及其反转中是否存在同一子字符串

```java
class Solution {
    public boolean isSubstringPresent(String s) {
        StringBuilder sb = new StringBuilder();
        sb.append(s);
        String t = sb.reverse().toString();
        for (int i = 0; i < s.length() - 1; i++) {
            String part = s.substring(i, i + 2);
            if (t.indexOf(part) != -1) {
                return true;
            }
        }
        return false;
    }
}
```



# 3090.每个字符最多出现两次的最长子字符串

```java
class Solution {
    public int maximumLengthSubstring(String s) {
        int[] letterList = new int[26];
        int left = 0;
        int right = 0;
        int result = 0;
        while (right < s.length()) {
            int index = s.charAt(right++) - 'a';
            letterList[index]++;
            while (letterList[index] > 2) {
                int indexTemp = s.charAt(left++) - 'a';
                letterList[indexTemp]--;
            }
            result = Math.max(result, right - left);
        }
        return result;
    }
}
```

# 3095.或值至少K的最短子数组Ⅰ

```java
class Solution {
    public int minimumSubarrayLength(int[] nums, int k) {
        int result = 999;
        for (int i = 0; i < nums.length; i++) {
            int orAnswer = 0;
            for (int j = i; j < nums.length; j++) {
                orAnswer |= nums[j];
                if (orAnswer >= k) {
                    result = Math.min(result, j - i + 1);
                    break;
                }
            }
        }
        return result == 999 ? -1 : result;
    }
}
```



# 3100.换水问题Ⅱ

```java
class Solution {
    public int maxBottlesDrunk(int numBottles, int numExchange) {
        int result = numBottles;
        while (numBottles >= numExchange) {
            result++;
            numBottles -= (numExchange - 1);
            numExchange++;
        }
        return result;
    }
}
```

