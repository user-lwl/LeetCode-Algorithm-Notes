# 3005.最大频率元素计数

```java
class Solution {
    public int maxFrequencyElements(int[] nums) {
        int[] cntList = new int[101];
        for (int i = 0; i < nums.length; i++) {
            cntList[nums[i]]++;
        }
        Arrays.sort(cntList);
        int result = cntList[cntList.length - 1];
        for (int i = cntList.length - 2; i >= 0; i--) {
            if (cntList[i] == cntList[i + 1]) {
                result += cntList[i];
            } else {
                break;
            }
        }
        return result;
    }
}
```



# 3010.将数组分成最小总代价的子数组Ⅰ

```java
class Solution {
    public int minimumCost(int[] nums) {
        int first = nums[0];
        Arrays.sort(nums);
        int sum = 0;
        for (int i = 0; i < 2; i++) {
            sum += nums[i];
        }
        if (nums[1] >= first) {
            sum += nums[2];
        } else {
            sum += first;
        }
        return sum;
    }
}
```

# 3014.输入单词需要的最少按键次数Ⅰ

```java
class Solution {
    public int minimumPushes(String word) {
        int len = word.length();
        int result = 0;
        result += Math.min(8, len);
        len -= 8;
        if (len > 0) {
            result += Math.min(8, len) * 2;
            len -= 8;
        }
        if (len > 0) {
            result += Math.min(8, len) * 3;
            len -= 8;
        }
        if (len > 0) {
            result += len * 4;
        }
        return result;
    }
}
```

# 3019.按键变更的次数

```java
class Solution {
    public int countKeyChanges(String s) {
        int result = 0;
        for (int i = 1; i < s.length(); i++) {
            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(i - 1))) {
                result++;
            }
        }
        return result;
    }
}
```



# 3024.三角形类型

```java
class Solution {
    public String triangleType(int[] nums) {
        Arrays.sort(nums);
        int line1 = nums[0];
        int line2 = nums[1];
        int line3 = nums[2];
        if (line1 + line2 > line3) {
            if (line1 == line2 || line2 == line3 || line1 == line3) {
                if (line1 == line2 && line2 == line3) {
                    return "equilateral";
                } else {
                    return "isosceles";
                }
            } else {
                return "scalene";
            }
        }
        return "none";
    }
}
```

# 3028.边界上的蚂蚁

```java
class Solution {
    public int returnToBoundaryCount(int[] nums) {
        int result = 0;
        int index = 0;
        for (int i = 0; i < nums.length; i++) {
            index += nums[i];
            if (index == 0) {
                result++;
            }
        }
        return result;
    }
}
```



# 3033.修改矩阵

```java
class Solution {
    public int[][] modifiedMatrix(int[][] matrix) {
        int[] maxLie = new int[matrix[0].length];
        for (int i = 0; i < matrix.length; i++) {
            for (int j = 0; j < matrix[0].length; j++) {
                maxLie[j] = Math.max(maxLie[j], matrix[i][j]);
            }
        }
        for (int i = 0; i < matrix.length; i++) {
            for (int j = 0; j < matrix[0].length; j++) {
                if (matrix[i][j] == -1) {
                    matrix[i][j] = maxLie[j];
                }
            }
        }
        return matrix;
    }
}
```

# 3038.相同分数的最大操作数目Ⅰ

```java
class Solution {
    public int maxOperations(int[] nums) {
        int cnt = 0;
        int temp = nums[0] + nums[1];
        for (int i = 0; i < nums.length - 1; i += 2) {
            if (temp == nums[i] + nums[i + 1]) {
                cnt++;
            } else {
                break;
            }
        }
        return cnt;
    }
}
```



# 3042.统计前后缀下标对Ⅰ

```java
class Solution {
    public int countPrefixSuffixPairs(String[] words) {
        int result = 0;
        for (int i = 0; i < words.length; i++) {
            for (int j = i + 1; j < words.length; j++) {
                if (isPrefixAndSuffix(words[j], words[i])) {
                    result++;
                }
            }
        }
        return result;
    }

    public boolean isPrefixAndSuffix(String str1, String str2) {
        if (str1.length() < str2.length()) {
            return false;
        }
        return str1.indexOf(str2) == 0 && str2.equals(str1.substring(str1.length() - str2.length()));
    }
}
```



# 3046.分割数组

```java
class Solution {
    public boolean isPossibleToSplit(int[] nums) {
        int[] cnt = new int[101];
        for (int i = 0; i < nums.length; i++) {
            cnt[nums[i]]++;
        }
        for (int i = 0; i < cnt.length; i++) {
            if (cnt[i] > 2) {
                return false;
            }
        }
        return true;
    }
}
```

# 3065.超过阈值的最少操作数Ⅰ

```java
class Solution {
    public int minOperations(int[] nums, int k) {
        Arrays.sort(nums);
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] >= k) {
                return i;
            }
        }
        return nums.length;
    }
}
```

# 3069.将元素分配到两个数组中Ⅰ

```java
class Solution {
    public int[] resultArray(int[] nums) {
        List<Integer> arr1 = new ArrayList<>();
        List<Integer> arr2 = new ArrayList<>();
        arr1.add(nums[0]);
        if (nums.length > 1) {
            arr2.add(nums[1]);
        }
        for (int i = 2; i < nums.length; i++) {
            if (arr1.get(arr1.size() - 1) > arr2.get(arr2.size() - 1)) {
                arr1.add(nums[i]);
            } else {
                arr2.add(nums[i]);
            }
        }
        int[] result = new int[nums.length];
        int index = 0;
        for (int i = 0; i < arr1.size(); i++) {
            result[index++] = arr1.get(i);
        }
        for (int i = 0; i < arr2.size(); i++) {
            result[index++] = arr2.get(i);
        }
        return result;
    }
}
```



# 3074.重新分装苹果

```java
class Solution {
    public int minimumBoxes(int[] apple, int[] capacity) {
        int sum = 0;
        for (int i = 0; i < apple.length; i++) {
            sum += apple[i];
        }
        Integer[] Integernum = Arrays.stream(capacity).boxed().toArray(Integer[]::new);
        Arrays.sort(Integernum, new Comparator<Integer>() {
            public int compare(Integer o1, Integer o2) {
                return o2 - o1;
            }
        });
        for (int i = 0; i < Integernum.length; i++) {
            sum -= Integernum[i];
            if (sum <= 0) {
                return i + 1;
            }
        }
        return -1;
    }
}
```

# 3079.求出加密整数的和

```java
class Solution {
    public int sumOfEncryptedInt(int[] nums) {
        int result = 0;
        for (int i = 0; i < nums.length; i++) {
            int temp = nums[i];
            int cnt = 0;
            int number = 0;
            while (temp > 0) {
                number = Math.max(number, temp % 10);
                temp /= 10;
                cnt++;
            }
            int tempNumber = 0;
            while (cnt > 0) {
                tempNumber = tempNumber * 10 + number;
                cnt--;
            }
            result += tempNumber;
        }
        return result;
    }
}
```



# 3083.字符串及其反转中是否存在同一子字符串

```java
class Solution {
    public boolean isSubstringPresent(String s) {
        StringBuilder sb = new StringBuilder();
        sb.append(s);
        String t = sb.reverse().toString();
        for (int i = 0; i < s.length() - 1; i++) {
            String part = s.substring(i, i + 2);
            if (t.indexOf(part) != -1) {
                return true;
            }
        }
        return false;
    }
}
```



# 3090.每个字符最多出现两次的最长子字符串

```java
class Solution {
    public int maximumLengthSubstring(String s) {
        int[] letterList = new int[26];
        int left = 0;
        int right = 0;
        int result = 0;
        while (right < s.length()) {
            int index = s.charAt(right++) - 'a';
            letterList[index]++;
            while (letterList[index] > 2) {
                int indexTemp = s.charAt(left++) - 'a';
                letterList[indexTemp]--;
            }
            result = Math.max(result, right - left);
        }
        return result;
    }
}
```

# 3095.或值至少K的最短子数组Ⅰ

```java
class Solution {
    public int minimumSubarrayLength(int[] nums, int k) {
        int result = 999;
        for (int i = 0; i < nums.length; i++) {
            int orAnswer = 0;
            for (int j = i; j < nums.length; j++) {
                orAnswer |= nums[j];
                if (orAnswer >= k) {
                    result = Math.min(result, j - i + 1);
                    break;
                }
            }
        }
        return result == 999 ? -1 : result;
    }
}
```

# 3099.哈沙德数

```java
class Solution {
    public int sumOfTheDigitsOfHarshadNumber(int x) {
        int sum = 0;
        int number = x;
        while (number > 0) {
            sum += number % 10;
            number /= 10;
        }
        if (x % sum == 0) {
            return sum;
        }
        return -1;
    }
}
```



# 3100.换水问题Ⅱ

```java
class Solution {
    public int maxBottlesDrunk(int numBottles, int numExchange) {
        int result = numBottles;
        while (numBottles >= numExchange) {
            result++;
            numBottles -= (numExchange - 1);
            numExchange++;
        }
        return result;
    }
}
```

