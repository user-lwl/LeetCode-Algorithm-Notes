# 802.找到最终的安全状态

```java
class Solution {
    public List<Integer> eventualSafeNodes(int[][] graph) {
        // 首先得到反图 ungraph 及其入度数组 unin
        // 将所有入度为 0 的点加入队列
        // 然后不断取出队首元素，将其出边相连的点的入度减一
        // 若该点入度减一后为 0，则将该点加入队列，如此循环直至队列为空
        // 循环结束后，所有入度为 0 的节点均为安全的
        List<List<Integer>> ungraph = new ArrayList<>();
        int len = graph.length;
        for (int i = 0; i < len; i++) {
            ungraph.add(new ArrayList<>());
        }
        int[] unin = new int[len];
        for (int i = 0; i < len; i++) {
            for (int j : graph[i]) {
                ungraph.get(j).add(i);
            }
            unin[i] = graph[i].length;
        }
        Deque<Integer> queue = new LinkedList<>();
        for (int i = 0; i < len; i++) {
            if (unin[i] == 0) {
                queue.addLast(i);
            }
        }
        while (!queue.isEmpty()) {
            int t = queue.poll();
            for (int u : ungraph.get(t)) {
                unin[u]--;
                if (unin[u] == 0) {
                    queue.addLast(u);
                }
            }
        }
        List<Integer> result = new ArrayList<>();
        for (int i = 0; i < len; i++) {
            if(unin[i] == 0) {
                result.add(i);
            }
        }
        return result;
    }
}
```



# 804.唯一摩尔斯密码词

```java
class Solution {
    public int uniqueMorseRepresentations(String[] words) {
        String[] moSi = new String[]{".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."};
        Set<String> resultSet = new HashSet<>();
        for (int i = 0; i < words.length; i++) {
            char[] tempChar = words[i].toCharArray();
            StringBuilder sb = new StringBuilder();
            for (int j = 0; j < tempChar.length; j++) {
                sb.append(moSi[tempChar[j] - 'a']);
            }
            resultSet.add(sb.toString());
        }
        return resultSet.size();
    }
}
```

# 812.最大三角形面积

```java
class Solution {
    public double largestTriangleArea(int[][] points) {
        double result = 0;
        for (int i = 0; i < points.length; i++) {
            for (int j = i + 1; j < points.length; j++) {
                for (int k = j + 1; k < points.length; k++) {
                    int x1 = points[i][0];
                    int y1 = points[i][1];
                    int x2 = points[j][0];
                    int y2 = points[j][1];
                    int x3 = points[k][0];
                    int y3 = points[k][1];
                    double area = 0.5 * Math.abs(x1 * y2 + x2 * y3 + x3 * y1 - x1 * y3 - x2 * y1 - x3 * y2);
                    result = Math.max(area, result);
                }
            }
        }
        return result;
    }
}
```



# 817.链表组件

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public int numComponents(ListNode head, int[] nums) {
        Set<Integer> set = new HashSet<>();
        for (int i = 0; i < nums.length; i++) {
            set.add(nums[i]);
        }
        ListNode newHead = new ListNode(-1, head);
        int result = 0;
        while (newHead != null && newHead.next != null) {
            if (set.contains(newHead.next.val) && !set.contains(newHead.val)) {
                result++;
            }
            newHead = newHead.next;
        }
        return result;
    }
}
```

# 819.最常见的单词

```java
class Solution {
    public String mostCommonWord(String paragraph, String[] banned) {
        Set<String> bannedSet = new HashSet<>();
        for (int i = 0; i < banned.length; i++) {
            bannedSet.add(banned[i]);
        }
        char[] paragraphList = paragraph.toLowerCase().toCharArray();
        Map<String, Integer> resultMap = new HashMap<>();
        for (int i = 0; i < paragraphList.length; i++) {
            if (Character.isLetter(paragraphList[i])) {
                StringBuilder sb = new StringBuilder();
                for (; i < paragraphList.length; i++) {
                    if (Character.isLetter(paragraphList[i])) {
                        sb.append(paragraphList[i]);
                        if (i == paragraphList.length - 1) {
                            resultMap.put(sb.toString(), resultMap.getOrDefault(sb.toString(), 0) + 1);
                        }
                    } else {
                        if (bannedSet.contains(sb.toString())) {
                            break;
                        }
                        resultMap.put(sb.toString(), resultMap.getOrDefault(sb.toString(), 0) + 1);
                        break;
                    }
                }
            }
        }
        int maxCnt = 0;
        String resultString = null;
        for (String key : resultMap.keySet()) {
            int tempCnt = resultMap.get(key);
            if (tempCnt > maxCnt) {
                maxCnt = tempCnt;
                resultString = key;
            }
        }
        return resultString;
    }
}
```

# 821.字符的最短距离

```java
class Solution {
    public int[] shortestToChar(String s, char c) {
        List<Integer> index = new ArrayList<>();
        char[] sChar = s.toCharArray();
        index.add(999999);
        for (int i = 0; i < sChar.length; i++) {
            if (sChar[i] == c) {
                index.add(i);
            }
        }
        index.add(999999);
        int left = index.get(0);
        int right = index.get(1);
        int tempIndex = 2;
        int[] result = new int[sChar.length];
        for (int i = 0; i < sChar.length; i++) {
            int minLen = Math.min(Math.abs(i - left), Math.abs(i - right));
            if (minLen == 0) {
                left = right;
                right = index.get(tempIndex++);
            }
            result[i] = minLen;
        }
        return result;
    }
}
```



# 832.翻转图像

```java
class Solution {
    public int[][] flipAndInvertImage(int[][] image) {
        int len = image.length;
        for (int i = 0; i < len; i++) {
            for (int j = 0; j < len / 2; j++) {
                int temp = image[i][j];
                image[i][j] = image[i][len - 1 - j];
                image[i][len - 1 - j] = temp;
            }
        }
        for (int i = 0; i < len; i++) {
            for (int j = 0; j < len; j++) {
                image[i][j] = image[i][j] == 0 ? 1:0;
            }
        }
        return image;
    }
}
```

# 844.比较含退格的字符串

```java
class Solution {
    public boolean backspaceCompare(String s, String t) {
        LinkedList<Character> sList = new LinkedList<>();
        LinkedList<Character> tList = new LinkedList<>();
        char[] sChar = s.toCharArray();
        char[] tChar = t.toCharArray();
        for (int i = 0; i < sChar.length; i++) {
            if (sChar[i] == '#') {
                if (sList.isEmpty()) {
                    continue;
                }
                sList.removeLast();
            } else {
                sList.addLast(sChar[i]);
            }
        }
        for (int i = 0; i < tChar.length; i++) {
            if (tChar[i] == '#') {
                if (tList.isEmpty()) {
                    continue;
                }
                tList.removeLast();
            } else {
                tList.addLast(tChar[i]);
            }
        }
        if (sList.size() != tList.size()) {
            return false;
        }
        while (!sList.isEmpty() && !tList.isEmpty()) {
            char tempChar1 = sList.removeFirst();
            char tempChar2 = tList.removeFirst();
            if (tempChar1 != tempChar2) {
                return false;
            }
        }
        return true;
    }
}
```



# 851.喧闹和富有

```java
class Solution {
    public int[] loudAndRich(int[][] richer, int[] quiet) {
        int len = quiet.length;
        int[][] graph = new int[len][len];
        int[] in = new int[len];
        for (int[] rich : richer) {
            int a = rich[0];
            int b = rich[1];
            graph[a][b] = 1;
            in[b]++;
        }
        Deque<Integer> queue = new ArrayDeque<>();
        int[] result = new int[len];
        for (int i = 0; i < len; i++) {
            result[i] = i;
            if (in[i] == 0) {
                queue.addLast(i);
            }
        }
        // 利用跑拓扑排序过程中的 t−>u 关系
        // 尝试使用 ans[t] 更新 ans[u]
        // （由于存在 t 指向 u 的边，说明 t 比 u 有钱
        // 此时检查两者的安静值，若满足 quiet[ans[t]]<quiet[ans[u]]
        // 则用 ans[t] 更新 ans[u]）
        while (!queue.isEmpty()) {
            int t = queue.pollFirst();
            for (int u = 0; u < len; u++) {
                if (graph[t][u] == 1) {
                    if (quiet[result[t]] < quiet[result[u]]) {
                        result[u] = result[t];
                    }
                    in[u]--;
                    if (in[u] == 0) {
                        queue.addLast(u);
                    }
                }
            }
        }
        return result;
    }
}
```

# 859.亲密字符串

```java
class Solution {
    public boolean buddyStrings(String s, String goal) {
        char[] sCharList = s.toCharArray();
        char[] goalCharList = goal.toCharArray();
        Map<Integer, Character[]> errMap = new HashMap<>();
        Map<Character, Integer> cntMap = new HashMap<>();
        if (sCharList.length != goalCharList.length) {
            return false;
        }
        for (int i = 0; i < sCharList.length; i++) {
            cntMap.put(sCharList[i], cntMap.getOrDefault(sCharList[i], 0) + 1);
            if (sCharList[i] != goalCharList[i]) {
                errMap.put(errMap.size() + 1, new Character[]{sCharList[i], goalCharList[i]});
                if (errMap.size() > 2) {
                    return false;
                }
            }
        }
        if (errMap.size() == 2) {
            Character[] tempChar1 = errMap.get(1);
            Character[] tempChar2 = errMap.get(2);
            return tempChar1[0] == tempChar2[1] && tempChar1[1] == tempChar2[0];
        }
        if (errMap.size() == 0) {
            for (Character tempChar : cntMap.keySet()) {
                if (cntMap.get(tempChar) > 1) {
                    return true;
                }
            }
        }
        return false;
    }
}
```



# 860.柠檬水找零

```java
class Solution {
    public boolean lemonadeChange(int[] bills) {
        int money5 = 0;
        int money10 = 0;
        for (int i = 0; i < bills.length; i++) {
            if (bills[i] == 5) {
                money5++;
            } else if (bills[i] == 10) {
                money10++;
                money5--;
            } else {
                if (money10 == 0) {
                    money5 -= 2;
                }else {
                    money10--;
                }
                money5--;
            }
            if (money10 < 0 || money5 < 0) {
                return false;
            }
        }
        return true;
    }
}
```



# 867.转置矩阵

```java
class Solution {
    public int[][] transpose(int[][] matrix) {
        int m = matrix.length;
        int n = matrix[0].length;
        int[][] result = new int[n][m];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                result[j][i] = matrix[i][j];
            }
        }
        return result;
    }
}
```

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode trainingPlan(ListNode head, int cnt) {
        ListNode left = head;
        ListNode right = head;
        for (int i = 0; i < cnt - 1; i++) {
            right = right.next;
        }
        while (right.next != null) {
            left = left.next;
            right = right.next;
        }
        return left;
    }
}
```



# 876.链表的中间结点

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode middleNode(ListNode head) {
        ListNode left = head;
        ListNode right = head;
        while (right != null) {
            if (right.next != null && right.next.next == null) {
                return left.next;
            } else if (right.next == null) {
                return left;
            } else {
                left = left.next;
                right = right.next.next;
            }
        }
        return left;
    }
}
```

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode middleNode(ListNode head) {
        ListNode left = head;
        ListNode right = head;
        while (right != null && right.next != null) {
            left = left.next;
            right = right.next.next;
        }
        return left;
    }
}
```



# 881.救生艇

```java
class Solution {
    public int numRescueBoats(int[] people, int limit) {
        int left = 0; 
        int right;
        int number = 0;
        Arrays.sort(people);
        for (right = people.length - 1; right >= left; right--) {
            if (right == left) {
                number++;
                break;
            }
            if (people[right] + people[left] <= limit) {
                left++;
            }
            number++;
        }
        return number;
    }
}
```

# 883.三维形体投影面积

```java
class Solution {
    public int projectionArea(int[][] grid) {
        int bottom = 0;
        int[] hangMax = new int[grid.length];
        int[] lieMax = new int[grid[0].length];
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid.length; j++) {
                if (grid[i][j] != 0) {
                    bottom++;
                }
                hangMax[i] = Math.max(hangMax[i], grid[i][j]);
                lieMax[j] = Math.max(lieMax[j], grid[i][j]);
            }
        }
        int result = bottom;
        for (int i = 0; i < hangMax.length; i++) {
            result += hangMax[i];
        }
        for (int i = 0; i < lieMax.length; i++) {
            result += lieMax[i];
        }
        return result;
    }
}
```



# 884.两句话中的不常见单词

```java
class Solution {
    public String[] uncommonFromSentences(String s1, String s2) {
        String[] splitS1 = s1.split(" ");
        String[] splitS2 = s2.split(" ");
        Map<String, Integer> s1Map = new HashMap<>();
        Map<String, Integer> s2Map = new HashMap<>();
        for (int i = 0; i < splitS1.length; i++) {
            s1Map.put(splitS1[i], s1Map.getOrDefault(splitS1[i], 0) + 1);
        }
        for (int i = 0; i < splitS2.length; i++) {
            s2Map.put(splitS2[i], s2Map.getOrDefault(splitS2[i], 0) + 1);
        }
        List<String> resultList = new ArrayList<>();
        for (String key : s1Map.keySet()) {
            if (s1Map.get(key) == 1 && s2Map.getOrDefault(key, -1) == -1) {
                resultList.add(key);
            }
        }
        for (String key : s2Map.keySet()) {
            if (s2Map.get(key) == 1 && s1Map.getOrDefault(key, -1) == -1) {
                resultList.add(key);
            }
        }
        String[] result = new String[resultList.size()];
        for (int i = 0; i < resultList.size(); i++) {
            result[i] = resultList.get(i);
        }
        return result;
    }
}
```



# 888.公平的糖果交换

```java
class Solution {
    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {
        Set<Integer> bobSet = new HashSet<>();
        int aliceSum = 0;
        int bobSum = 0;
        for (int i = 0; i < aliceSizes.length; i++) {
            aliceSum += aliceSizes[i];
        }
        for (int i = 0; i < bobSizes.length; i++) {
            bobSet.add(bobSizes[i]);
            bobSum += bobSizes[i];
        }
        int temp = aliceSum - bobSum;
        int[] result = new int[2];
        for (int i = 0; i < aliceSizes.length; i++) {
            if (bobSet.contains(aliceSizes[i] - temp / 2)) {
                result[0] = aliceSizes[i];
                result[1] = aliceSizes[i] - temp / 2;
                break;
            }
        }
        return result;
    }
}
```

# 892.三维形体的表面积

```java
class Solution {
    public int surfaceArea(int[][] grid) {
        int result = 0;
        List<int[]> zeroIndex = new ArrayList<>();
        for (int i = 0; i < grid.length; i++) {
            result += grid[0][i] + grid[grid.length - 1][i] + grid[i][0] + grid[i][grid[0].length - 1];
        }
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[0].length; j++) {
                if (grid[i][j] != 0) {
                    result += 2;
                }
                if (i == 0 && i == grid.length - 1) {
                    break;
                } else if (i == 0) {
                    result += Math.max(grid[i][j] - grid[i + 1][j], 0);
                } else if (i == grid.length - 1) {
                    result += Math.max(grid[i][j] - grid[i - 1][j], 0);
                } else {
                    result += Math.max(grid[i][j] - grid[i - 1][j], 0) + Math.max(grid[i][j] - grid[i + 1][j], 0);
                }
                if (j == 0 && j == grid[0].length - 1) {
                    break;
                } else if (j == 0) {
                    result += Math.max(grid[i][j] - grid[i][j + 1], 0);
                } else if (j == grid.length - 1) {
                    result += Math.max(grid[i][j] - grid[i][j - 1], 0);
                } else {
                    result += Math.max(grid[i][j] - grid[i][j - 1], 0) + Math.max(grid[i][j] - grid[i][j + 1], 0);
                }
            }
        }
        return result;
    }
}
```



# 897.递增顺序搜索树

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    List<Integer> list;
    public TreeNode increasingBST(TreeNode root) {
        list = new ArrayList<>();
        inorder(root);
        TreeNode node = new TreeNode();
        TreeNode temp = node;
        for (int i = 0; i < list.size(); i++) {
            if (i < list.size() - 1) {
                temp.right = new TreeNode();
            }
            temp.val = list.get(i);
            temp = temp.right;
        }
        return node;
    }
    public void inorder(TreeNode node) {
        if (node == null) {
            return;
        }
        inorder(node.left);
        list.add(node.val);
        inorder(node.right);
    }
}
```

