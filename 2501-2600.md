# 2506.统计相似字符串对的数目

```java
class Solution {
    public int similarPairs(String[] words) {
        for (int i = 0; i < words.length; i++) {
            int[] number = new int[26];
            for (int j = 0; j < words[i].length(); j++) {
                number[words[i].charAt(j) - 'a']++;
            }
            StringBuilder sb = new StringBuilder();
            for (int j = 0; j < number.length; j++) {
                if (number[j] != 0) {
                    sb.append((char) (j + 'a'));
                }
            }
            words[i] = sb.toString();
        }
        int result = 0;
        for (int i = 0; i < words.length; i++) {
            for (int j = i + 1; j < words.length; j++) {
                if (words[i].equals(words[j])) {
                    result++;
                }
            }
        }
        return result;
    }
}
```

# 2511.最多可以摧毁的敌人城堡数目

```java
class Solution {
    public int captureForts(int[] forts) {
        int result = 0;
        for (int i = 0; i < forts.length; i++) {
            int temp = forts[i];
            int startIndex = i;
            if (temp == 1 || temp == -1) {
                i++;
                while (i < forts.length && forts[i] == 0) {
                    i++;
                }
                if (i == forts.length) {
                    break;
                }
                if (temp + forts[i] == 0) {
                    result = Math.max(result, i - startIndex - 1);
                }
                i--;
            }
        }
        return result;
    }
}
```



# 2515.到目标字符串的最短距离

```java
class Solution {
    public int closestTarget(String[] words, String target, int startIndex) {
        String[] wordAndWord = new String[words.length * 2];
        System.arraycopy(words, 0, wordAndWord, 0, words.length);
        System.arraycopy(words, 0, wordAndWord, words.length, words.length);
        int minIndex = -1;
        int maxIndex = -1;
        for (int i = startIndex; i < startIndex + words.length; i++) {
            if (wordAndWord[i].equals(target)) {
                if (minIndex == -1) {
                    minIndex = i;
                    maxIndex = i;
                } else {
                    maxIndex = i;
                }
            }
        }
        return minIndex == -1 ? minIndex : Math.min(minIndex - startIndex, words.length - maxIndex + startIndex);
    }
}
```



# 2529.正整数和负整数的最大计数

```java
class Solution {
    public int maximumCount(int[] nums) {
        int zzs = 0;
        int fzs = 0;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] > 0) {
                zzs++;
            } else if (nums[i] < 0) {
                fzs++;
            }
        }
        return Math.max(zzs, fzs);
    }
}
```



# 2535.数组元素和与数字和的绝对差

```java
class Solution {
    public int differenceOfSum(int[] nums) {
        int sum = 0;
        int tempSum = 0;
        for (int i = 0; i < nums.length; i++) {
            sum += nums[i];
            int temp = nums[i];
            while (temp > 0) {
                tempSum = tempSum + temp % 10;
                temp /= 10;
            }
        }
        return Math.abs(sum - tempSum);
    }
}
```

# 2540.最小公共值

```java
class Solution {
    public int getCommon(int[] nums1, int[] nums2) {
        Set<Integer> tempSet = new HashSet<>();
        for (int i = 0; i < nums1.length; i++) {
            tempSet.add(nums1[i]);
        }
        for (int i = 0; i < nums2.length; i++) {
            if (tempSet.contains(nums2[i])) {
                return nums2[i];
            }
        }
        return -1;
    }
}
```

# 2549.统计桌面上的不同数字

```java
class Solution {
    public int distinctIntegers(int n) {
        return n == 1 ? 1 : n - 1;
    }
}
```



# 2552.统计上升四元组

```java
/**
 * 超时
 */
class Solution {
    int maxn = 4001;
    int[][] less = new int[maxn][maxn];
    int[][] bigger = new int[maxn][maxn];
    public long countQuadruplets(int[] nums) {
        int n = nums.length;
        for (int i = 1; i <= n; i++) {
            less[0][i] = 0;
        }
        for (int i = 1; i < n; i++) {
            int x = nums[i - 1];
            for (int j = 1; j <= n; j++) {
                if (x < j) {
                    less[i][j] = less[i - 1][j] + 1;
                } else {
                    less[i][j] = less[i - 1][j];
                }
            }
        }
        for (int i = 1; i <= n; i++) {
            bigger[n - 1][i] = 0;
        }
        for (int i = n - 2; i >= 0 ;i--) {
            int x = nums[i + 1];
            for (int j = 1; j <= n; j++) {
                if (x > j) {
                    bigger[i][j] = bigger[i + 1][j] + 1;
                } else {
                    bigger[i][j] = bigger[i + 1][j];
                }
            }
        }
        long result = 0;
        for (int j = 0; j < n; j++) {
            for (int k = j + 1; k < n; k++) {
                if (nums[k] < nums[j]) {
                    result += less[j][nums[k]] * bigger[k][nums[j]];
                }
            }
        }
        return result;
    }
}
```

```java
class Solution {
    public long countQuadruplets(int[] nums) {
        int n = nums.length;
        int[][] great = new int[n][n + 1];
        for (int k = n - 2; k > 0; k--) {
            great[k] = great[k + 1].clone();
            for (int x = nums[k + 1] - 1; x > 0; x--)
                great[k][x]++;
        }

        long ans = 0;
        for (int j = 1; j < n - 2; j++)
            for (int k = j + 1; k < n - 1; k++) {
                int x = nums[k];
                if (nums[j] > x)
                    ans += (x - n + 1 + j + great[j][x]) * great[k][nums[j]];
            }
        return ans;
    }
}
```

# 2553.分割数组中数字的数位

```java
class Solution {
    public int[] separateDigits(int[] nums) {
        List<Integer> tempList = new ArrayList<>();
        for (int i = 0; i < nums.length; i++) {
            List<Integer> temp = new ArrayList<>();
            int tempInt = nums[i];
            while (tempInt > 0) {
                temp.add(tempInt % 10);
                tempInt /= 10;
            }
            Collections.reverse(temp);
            tempList.addAll(temp);
        }
        int[] result = new int[tempList.size()];
        for (int i = 0; i < tempList.size(); i++) {
            result[i] = tempList.get(i);
        }
        return result;
    }
}
```

# 2558.从数量最多的堆取走礼物

```java
class Solution {
    public long pickGifts(int[] gifts, int k) {
        while (k > 0) {
            Arrays.sort(gifts);
            gifts[gifts.length - 1] = (int) Math.sqrt(gifts[gifts.length - 1]);
            k--;
        }
        long sum = 0;
        for (int i = 0; i < gifts.length; i++) {
            sum += (long) gifts[i];
        }
        return sum;
    }
}
```

# 2562.找出数组的串联值

```java
class Solution {
    public long findTheArrayConcVal(int[] nums) {
        int left = 0;
        int right = nums.length - 1;
        long result = 0;
        while (left < right) {
            long temp = (long) Integer.valueOf(String.valueOf(nums[left++]) + String.valueOf(nums[right--]));
            result += temp;
        }
        if (left == right) {
            result += nums[left];
        }
        return result;
    }
}
```



# 2563.统计公平数对的数目

```java
class Solution {
    public long countFairPairs(int[] nums, int lower, int upper) {
        Arrays.sort(nums);
        long lessLower = lessThan(nums, lower - 1);
        long lessUpper = lessThan(nums, upper);
        return lessUpper - lessLower;
    }
    public long lessThan(int[] nums, int value) {
        int left = 0; 
        int right = nums.length - 1;
        long result = 0;
        while (left < right) {
            if(nums[left] + nums[right] <= value) {
                result += (right - left);
                left++;
            } else {
                right--;
            }
        }
        return result;
    }

}
```

# 2566.替换一个数字后的最大差值

```java
class Solution {
    public int minMaxDifference(int num) {
        String numString = String.valueOf(num);
        char[] numStringChar = numString.toCharArray();
        char maxReNumber = ' ';
        char minReNumber = numStringChar[0];
        int max = 0;
        int min = 0;
        for (int i = 0; i < numStringChar.length; i++) {
            if (numStringChar[i] != '9' && maxReNumber == ' ') {
                maxReNumber = numStringChar[i];
            }
            if (numStringChar[i] == maxReNumber) {
                max = max * 10 + 9;
            } else {
                max = max * 10 + (numStringChar[i] - '0');
            }
            if (numStringChar[i] == minReNumber) {
                min = min * 10 + 0;
            } else {
                min = min * 10 + (numStringChar[i] - '0');
            }
        }
        return max - min;
    }
}
```

# 2570.合并两个二维数组 - 求和法

```java
class Solution {
    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {
        int[] temp = new int[1001];
        Set<Integer> idSet = new HashSet<>();
        for (int i = 0; i < nums1.length; i++) {
            temp[nums1[i][0]] += nums1[i][1];
            idSet.add(nums1[i][0]);
        }
        for (int i = 0; i < nums2.length; i++) {
            temp[nums2[i][0]] += nums2[i][1];
            idSet.add(nums2[i][0]);
        }
        int[][] result = new int[idSet.size()][2];
        int index = 0;
        for (int i = 0; i < temp.length; i++) {
            if (temp[i] != 0) {
                result[index][0] = i;
                result[index][1] = temp[i];
                index++;
            }
        }
        return result;
    }
}
```



# 2574.左右元素和的差值

```java
class Solution {
    public int[] leftRightDifference(int[] nums) {
        int[] leftSum = new int[nums.length];
        int[] rightSum = new int[nums.length];
        for (int i = 1; i < nums.length; i++) {
            leftSum[i] = nums[i - 1] + leftSum[i - 1];
        }
        for (int i = nums.length - 2; i >= 0; i--) {
            rightSum[i] = nums[i + 1] + rightSum[i + 1];
        }
        int[] answer = new int[nums.length];
        for (int i = 0; i < nums.length; i++) {
            answer[i] = Math.abs(leftSum[i] - rightSum[i]);
        }
        return answer;
    }
}
```



# 2578.最小和分割

```java
class Solution {
    public int splitNum(int num) {
        char[] numChar = String.valueOf(num).toCharArray();
        Arrays.sort(numChar);
        int num1 = 0;
        int num2 = 0;
        for (int i = 0; i < numChar.length; i++) {
            int temp1 = numChar[i] - '0';
            num1 = num1 * 10 + temp1;
            if (i + 1 < numChar.length) {
                int temp2 = numChar[i + 1] - '0';
                num2 = num2 * 10 + temp2;
                i++;
            }
        }
        return num1 + num2;
    }
}
```

# 2586.统计范围内的元音字符串数

```java
class Solution {
    public int vowelStrings(String[] words, int left, int right) {
        Set<Character> yuanSet = new HashSet<>();
        yuanSet.add('a');
        yuanSet.add('e');
        yuanSet.add('i');
        yuanSet.add('o');
        yuanSet.add('u');
        int result = 0;
        for (int i = left; i <= right; i++) {
            if (yuanSet.contains(words[i].charAt(0)) && yuanSet.contains(words[i].charAt(words[i].length() - 1))) {
                result++;
            }
        }
        return result;
    }
}
```



# 2591.将钱分给最多的儿童

```java
class Solution {
    public int distMoney(int money, int children) {
        if (money < children) {
            return -1;
        }
        int moreMoney = money - children;
        int cnt = Math.min(moreMoney / 7, children);
        int lastMoney = moreMoney - cnt * 7;
        if ((lastMoney > 0 && cnt == children) || (lastMoney == 3 && (children - cnt) == 1)) {
            cnt--;
        }
        return cnt;
    }
}
```

# 2595.奇偶位数

```java
class Solution {
    public int[] evenOddBit(int n) {
        int even = 0;
        int odd = 0;
        for (int i = 31; i >= 0; i--) {
            if (((n >> i) & 1) == 1) {
                if (i % 2 ==0) {
                    even++;
                } else {
                    odd++;
                }
            }
        }
        return new int[]{even, odd};
    }
}
```



# 2600.K件物品的最大和

```java
class Solution {
    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {
        int result = 0;
        result += Math.min(numOnes, k);
        k -= numOnes;
        if (k > 0) {
            k -= numZeros;
        }
        if (k > 0) {
            result -= k;
        }
        return result;
    }
}
```

